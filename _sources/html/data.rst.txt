.. include:: /pentest_links.txt


****
Data
****

This discusses not just cookies, but in general browser storage & security.

cookies
=======

what is a cookie?
-----------------

Remember that HTTP is a stateless protocol but the HTTP servers often want to uniquely track a user across their web site. One way of doing that is cookies. The following is a summary of `HTTP cookie <http://en.wikipedia.org/wiki/HTTP_cookie>`_:

  Browsers are expected to support cookies where each cookie has a size of 4KB, at least 50 cookies per domain, and at least 3000 cookies total. It consists of seven components:

name (required)
  cookie name, returned to the server when domain, path, and secure connection matches

value (required)
  cookie value, returned to the server when domain, path, and secure connection matches

expiration
  cookie expiration, defaulting to session expiration (never returned to the server)

path
  path the cookie matches (never returned to the server)

domain
  domain the cookie matches (never returned to the server)

secure connection only
  cookie only allowed on secure connections

http_only
  cookie only accessible by http (i.e., not JavaScript, ...)


cookie creation
---------------

Cookies are created on the client when the server sends the HTTP "Set-Cookie:" directive; the client must return the cookie name & value back to the server via the HTTP "Cookie:" directive when the domain & path match the values in the cookie. Think about this security model: the server sends data to the client for storage, expecting that client (and only that client) to return the data back unaltered.

Here is some bash to show the cookie being sent by the server and stored in the file :file:`cookies.txt`:

.. code-block:: bash

  UA="Mozilla/5.0 (X11; Linux x86_64; rv:31.0)\
   Gecko/20100101 Firefox/31.0 Iceweasel/31.4.0"

  curl -v --head --cookie-jar cookies.txt --user-agent "$UA" \
      http://www.google.com/ 2>&1 | \
      grep "^Set-Cookie:"

  cat cookies.txt

Running this gives:

.. code-block:: console

  hacker@kali:~$ UA="Mozilla/5.0 (X11; Linux x86_64; rv:31.0)\
  >  Gecko/20100101 Firefox/31.0 Iceweasel/31.4.0"
  hacker@kali:~$ 
  hacker@kali:~$ curl -v --head --cookie-jar cookies.txt --user-agent "$UA" \
  >     http://www.google.com/ 2>&1 | \
  >     grep "^Set-Cookie:"
  Set-Cookie:
      PREF=
          ID=c7ff420bff37adf5:
          FF=0:
          TM=1424300122:
          LM=1424300122:
          S=H55eXGn_4gM0LpLp;
      expires=Fri, 17-Feb-2017 22:55:22 GMT;
      path=/;
      domain=.google.com
  Set-Cookie:
      NID=
          67=dD8uoSCgZWb73LkLjaLKNF9LrvUzO9lshxI9J2Y1VmikCkWq2PY\
          aabYHs5AMCRO7iKqJ5YqNhRgGfnbUiTGf_5P34qqkzJlZIXJHDZ6W7\
          09Jn1YvU07ERxNPMfbaaW33;
      expires=Thu, 20-Aug-2015 22:55:22 GMT;
      path=/;
      domain=.google.com;
      HttpOnly
  hacker@kali:~$ 
  hacker@kali:~$ cat cookies.txt
  # Netscape HTTP Cookie File
  # http://curl.haxx.se/rfc/cookie_spec.html
  # This file was generated by libcurl! Edit at your own risk.

  .google.com
      TRUE
      /
      FALSE
      1487372122
      PREF
          ID=c7ff420bff37adf5:
          FF=0:
          TM=1424300122:
          LM=1424300122:
          S=H55eXGn_4gM0LpLp
  #HttpOnly_
      .google.com
      TRUE
      /
      FALSE
      1440111322
      NID
          67=dD8uoSCgZWb73LkLjaLKNF9LrvUzO9lshxI9J2Y1VmikCkWq2PY\
          aabYHs5AMCRO7iKqJ5YqNhRgGfnbUiTGf_5P34qqkzJlZIXJHDZ6W7\
          09Jn1YvU07ERxNPMfbaaW33


:file:`cookie.txt` follows the Netscape tab-separated format: domain (preceded by "\$HttpOnly_" for http_only cookies), flag (T/F) indicating if all machines in a domain can access the cookie, path, secure (T/F), expiration (UNIX time), name, and value.
At this point the cookies PREF and NID are defined with PREF expiring in 2 years (!) and NID in 6 months. Both have path "/" and domain ".google.com" meaning that their name & value should be sent to the good server when requesting "\*.google.com/" via either http or https. NID is only accessible via http (and not via JavaScript). Neither is restricted to https.

It is up to the client to return the cookie's name & value to the server when the domain & path match. For ``curl`` to use the :file:`cookies.txt` file later use the ``--cookies`` option (along with ``--cookie-jar`` option to receive any return cookies):

.. code-block:: bash

  UA="Mozilla/5.0 (X11; Linux x86_64; rv:31.0)\
   Gecko/20100101 Firefox/31.0 Iceweasel/31.4.0"

  curl -v --user-agent "$UA" \
       --cookie cookies.txt --cookie-jar cookies.txt \
      https://www.google.com/?gws_rd=ssl#q=search+for+something 2>&1 | \
      egrep "(Set-Cookie:|Cookie:)"

Running this gives:

.. code-block:: console

  hacker@kali:~$ curl -v --user-agent "$UA" \
  >      --cookie cookies.txt --cookie-jar cookies.txt \
  >     https://www.google.com/?gws_rd=ssl#q=search+for+something 2>&1 | \
  >     egrep "(Set-Cookie:|Cookie:)"
  > Cookie:
      NID=
          67=dD8uoSCgZWb73LkLjaLKNF9LrvUzO9lshxI9J2Y1VmikCkWq2PY\
          aabYHs5AMCRO7iKqJ5YqNhRgGfnbUiTGf_5P34qqkzJlZIXJHDZ6W7\
          09Jn1YvU07ERxNPMfbaaW33;
      PREF=
          ID=c7ff420bff37adf5:
          FF=0:
          TM=1424300122:
          LM=1424300122:
          S=H55eXGn_4gM0LpLp
  < Set-Cookie:
       PREF=
           ID=c7ff420bff37adf5:
           U=42279cb0d37ac21e:
           FF=0:
           TM=1424300122:
           LM=1424300534:
           S=ZJhObjcMPBJ5byTr;
       expires=Fri, 17-Feb-2017 23:02:14 GMT;
       path=/;
       domain=.google.com
  < Set-Cookie:
       NID=
           67=sDvEPrthCRAEBl1Bc5mQv3_LBXLd4boLulRIxsIQ8FOMY5\
           AIYHVIdV5DTH0Q7nIuyL0QrQGkMVzxlUh6W-9KUE62Sek3JUK\
           d-1J_LXs33-4xhUpVWte7gVqyeP2sSMhg;
       expires=Thu, 20-Aug-2015 23:02:14 GMT;
       path=/;
       domain=.google.com;
       HttpOnly

cookie use
----------

`Cookie Uses <http://en.wikipedia.org/wiki/HTTP_cookie#Uses>`_ lists: session management, personalization, and tracking. `Types of cookies used by Google <https://www.google.com/intl/en/policies/technologies/types/>`_ mentions even more:

  Preferences:

    Most Google users will have a preferences cookie called ‘PREF’ in their browsers. A browser sends this cookie with requests to Google’s sites. The PREF cookie may store your preferences and other information, in particular your preferred language (e.g. English), how many search results you wish to have shown per page (e.g. 10 or 20), and whether or not you wish to have Google’s SafeSearch filter turned on. 

  Security:

    For example, we use cookies called ‘SID’ and ‘HSID’ which contain digitally signed and encrypted records of a user’s Google account ID and most recent sign-in time. The combination of these two cookies allows us to block many types of attack, such as attempts to steal the content of forms that you complete on web pages.

  Processes:

    For example, we use a cookie called ‘lbcs’ which makes it possible for Google Docs to open many Docs in one browser. Blocking this cookie would prevent Google Docs from operating correctly.

  Advertising:

    Google uses cookies, like the PREF, NID, and SID cookies, to help customize ads on Google properties, like Google Search.

    Our main advertising cookie on non-Google sites is called ‘id’ and it is stored in browsers under the domain doubleclick.net. We use others with names such as _drt_, FLC, and exchange_uid.

    Sometimes a cookie may be set on the domain of the site you are visiting. In the case of our DoubleClick product, a cookie called ‘__gads’ may be set on the domain of the site you are visiting.

  Session State:

    For example, we use a cookie called ‘recently_watched_video_id_list’ so that YouTube can record the videos most recently watched by a particular browser.

  Analytics:

    In addition to reporting website usage statistics, the Google Analytics pixel tag can also be used, together with some of the advertising cookies described above, to help show more relevant ads on Google properties (like Google Search) and across the web.

secure cookie sessions
----------------------

How can cookies be used securely and what difficulties are encountered? An example is found in `SCS: KoanLogic's Secure Cookie Sessions for HTTP <https://tools.ietf.org/html/rfc6896#section-3.2.4>`_ (RFC 6896), which "defines a generic URI and HTTP-header-friendly envelope for carrying symmetrically encrypted, authenticated, and origin-timestamped tokens." It takes the generic approach of "encrypt-then-MAC" the cookie.

.. code-block:: console

  # Box() = append strings, separating with "|"
  # Comp() = compress 
  # e() = encode (base 64)
  # Enc() = encrypt
  # RAND() = random number generator
  # TID = trapdoor key (used by encryption)
  IV = RAND()
  ATIME = NOW
  DATA = Enc(Comp(plain-text-cookie-value), IV)
  AUTHTAG = HMAC(Box(e(DATA), e(ATIME), e(TID), e(IV)))

  scs-cookie-value = Box(e(DATA), e(ATIME), e(TID), e(IV), e(AUTHTAG))

SCS protects the cookie value which normally would be plain text and tamperable. And it avoids the server-side problem of session ID prediction or brute-forcing. However, like normal cookies it does suffer from these shortcomings:

* Cookie Replay is not addressed. Additional steps needed might be:

  * Session inactivity timeout

  * Session voidance

    A list of possibly good cookies (using random values) is kept and deleted as cookies are used.

  * TLS binding

    Place data in the cookie tied to the current TLS session. This ties the client and server together and could affect scaling.

* Cookie Deletion

  A client could intentionally delete the cookie and therefore not use one. The application must be designed so there is no incentive to do so.

* Cookie Sharing or Theft

  * TLS binding (see above)

  * Securing the transmission (HTTPS, ...) reduces the chance of stolen cookies

  * Session cookies reduce the vulnerability window

* `Session fixation <https://www.owasp.org/index.php/Session_fixation>`_ is not addressed:

    "The Session Fixation attack fixes an established session on the victim's browser, so the attack starts before the user logs in."

  Like session hijacking, but instead of letting the client create the session then hijacking it, the attacker creates a session and makes the client use it.

Thankfully many web frameworks provide authentication and session management so web site authors don't have to bake in their own user identification, authentication, and authorization.

where are cookies stored?
-------------------------

Both :program:`firefox`/:program:`iceweasel` and Google :program:`chrome` store cookies in a SQLite database:

.. code-block:: console

  hacker@kali:~$ # -wal = SQLite write-ahead-log
  hacker@kali:~$ # -shm = shared memory file associated with the database
  hacker@kali:~$ #        used to access -wal
  hacker@kali:~$ FF=$(ls -1d $HOME/.mozilla/firefox/*.default)
  hacker@kali:~$ ls $FF/cookies.sqlite*
  /home/hacker/.mozilla/firefox/rj9fngpa.default/cookies.sqlite
  /home/hacker/.mozilla/firefox/rj9fngpa.default/cookies.sqlite-shm
  /home/hacker/.mozilla/firefox/rj9fngpa.default/cookies.sqlite-wal
  hacker@kali:~$ 
  hacker@kali:~$ GC=$HOME/.config/google-chrome/Default
  hacker@kali:~$ ls $GC/Cookies*
  /home/hacker/.config/google-chrome/Default/Cookies
  /home/hacker/.config/google-chrome/Default/Cookies-journal

.. code-block:: console

  hacker@kali:~$ sqlite3 $FF/cookies.sqlite
  SQLite version 3.7.16.2 2013-04-12 11:52:43
  Enter ".help" for instructions
  Enter SQL statements terminated with a ";"
  sqlite> 
  sqlite> 
  sqlite> .databases
  seq  name             file                                                      
  ---  ---------------  ----------------------------------------------------------
  0    main             /home/hacker/.mozilla/firefox/rj9fngpa.default/cookies.sql
  sqlite> 
  sqlite> 
  sqlite> .tables
  moz_cookies
  sqlite> 
  sqlite> 
  sqlite> .schema moz_cookies
  CREATE TABLE moz_cookies (id INTEGER PRIMARY KEY, baseDomain TEXT, 
      appId INTEGER DEFAULT 0, inBrowserElement INTEGER DEFAULT 0, name TEXT,
      value TEXT, host TEXT, path TEXT, expiry INTEGER, lastAccessed INTEGER,
      creationTime INTEGER, isSecure INTEGER, isHttpOnly INTEGER,
      CONSTRAINT moz_uniqueid UNIQUE (name, host, path, appId, inBrowserElement));
  CREATE INDEX moz_basedomain ON moz_cookies (baseDomain, appId, inBrowserElement);
  sqlite> 
  sqlite> 
  sqlite> select * from moz_cookies;
  ###################### SNIP ######################
  sqlite> .quit
  hacker@kali:~$ 
  hacker@kali:~$ 
  hacker@kali:~$ sqlite3 $GC/Cookies
  SQLite version 3.7.16.2 2013-04-12 11:52:43
  Enter ".help" for instructions
  Enter SQL statements terminated with a ";"
  sqlite> 
  sqlite> 
  sqlite> .databases
  seq  name             file                                                      
  ---  ---------------  ----------------------------------------------------------
  0    main             /home/hacker/.config/google-chrome/Default/Cookies        
  sqlite> 
  sqlite> 
  sqlite> .tables
  cookies  meta   
  sqlite> 
  sqlite> 
  sqlite> .schema meta
  CREATE TABLE meta(key LONGVARCHAR NOT NULL UNIQUE PRIMARY KEY, value LONGVARCHAR);
  sqlite> 
  sqlite> 
  sqlite> .schema cookies
  CREATE TABLE cookies (creation_utc INTEGER NOT NULL UNIQUE PRIMARY KEY,
      host_key TEXT NOT NULL,name TEXT NOT NULL,value TEXT NOT NULL,
      path TEXT NOT NULL,expires_utc INTEGER NOT NULL,
      secure INTEGER NOT NULL,httponly INTEGER NOT NULL,
      last_access_utc INTEGER NOT NULL, has_expires INTEGER NOT NULL DEFAULT 1,
      persistent INTEGER NOT NULL DEFAULT 1,priority INTEGER NOT NULL DEFAULT 1,
      encrypted_value BLOB DEFAULT '');
  CREATE INDEX domain ON cookies(host_key);
  sqlite> 
  sqlite> 
  sqlite> select * from cookies;
  ###################### SNIP ######################
  sqlite> .quit
  hacker@kali:~$ 

cookie handling within the browser
----------------------------------

Within :program:`chrome`, `CookieMonster <http://www.chromium.org/developers/design-documents/network-stack/cookiemonster>`_:

  The CookieMonster is the class in Chromium which handles in-browser storage, management, retrieval, expiration, and eviction of cookies. It does not handle interaction with the user or cookie policy (i.e. which cookies are accepted and which are not).  The code for the CookieMonster is contained in net/base/cookie_monster.{h,cc}.

  ...

  The CookieMonster has the following responsibilities:

  * When a server response is received specifying a cookie, it confirms that the cookie is valid, and stores it if so.  Tests for validity include:

    * The domain of the cookie must be .local or a subdomain of a public suffix (see http://publicsuffix.org/ - also known as an extended Top Level Domain).

    * The domain of the cookie must be a suffix of the domain from which the response was received.

    We do not enforce the RFC path or port restrictions

  * When a client request is being generated, a cookie in the store is included in that request if:

    * The cookie domain is a suffix of the server hostname.

    * The path of the cookie is a prefix of the request path.

    * The cookie must be unexpired.

  * It enforces limits (both per-origin and globally) on how many cookies will be stored.

tracking users across the Internet
----------------------------------

Here are 3 examples of tracking users on the Internet:

* `Looking Up Symptoms Online? these Companies Are Tracking You <http://motherboard.vice.com/read/looking-up-symptoms-online-these-companies-are-collecting-your-data>`_

    When you click that CDC link, you’re making a so-called “first party request.” That request goes to the CDC’s servers, and it returns the HTML file with the page you’re looking for. In this case, it’s “Genital Herpes - CDC Factsheet,” which is perhaps the page on the internet you’d least want anyone to know you’re looking at. But because the CDC has installed Google Analytics to measure its traffic stats, and has, for some reason, included AddThis code which allows Facebook and Twitter sharing (beckoning the question of who socializes disease pages), the CDC also sends a third party request to each of those companies. That request looks something like this—http://www.cdc.gov/std/herpes/STDFact-Herpes.htm—and makes explicit to those third party corporations in its HTTP referrer string that your search was about herpes.

* `Show Me Your Cookie And I Will Tell You Who You Are <http://arxiv.org/pdf/1108.5864.pdf>`_

    We analyzed Google Web Search access mechanisms and found that the current policy applied to session cookies could be used to retrieve users' personal data. We describe an attack scheme leveraging the search personalization (based on the same sid cookie) to retrieve a part of the victim's click history and even some of her contacts. We implemented a proof of concept of this attack on Firefox and Chrome Web browsers and conducted an experiment with ten volunteers. Thanks to this prototype we were able to recover up to 80% of the user's search click history.

* `Cookies from Nowhere <http://ashkansoltani.org/2012/02/25/cookies-from-nowhere/>`_

    The ‘.google.com’ PREF cookie enables cross-site tracking by Google’s +1 buttons. This button is similar in functionality to Facebook’s ‘Like button’ and other social widgets, which have been the subject of much attention for their ability to profile users across the web. As with the ‘Like button’, the PREF cookie and corresponding referer header (which reveals the page the user is browsing) is transmitted to Google anytime there is a +1 button present on a webpage (without the user taking any action).

And besides "normal" cookies, web sites have found additional ways to track user behavior across multiple web sites: third-party cookies, supercookies, zombie cookies, and tracking cookies:

Third party cookies
  come from third-pary content (i.e. 1 pixel images) delivered from the original web site. Placed across a large number of popular web sites, they can track users daily activies via the allowed third-party cookies.

  From `Website Search Results: independent.co.uk <http://cookiepedia.co.uk/website/independent.co.uk>`_ we see that site does plenty of third-party cookies and tracking. Using ``curl``:

  .. code-block:: bash

    UA="Mozilla/5.0 (X11; Linux x86_64; rv:31.0)\
     Gecko/20100101 Firefox/31.0 Iceweasel/31.4.0"
    curl -L -s  --user-agent "$UA" http://www.independent.co.uk/ 2>&1 | \
        grep '<img' | grep -v 'independent.co.uk' | \
        egrep '(imrworldwide|quantserve)'

  Running this shows a cgi-based image and a 1 pixel image:

  .. code-block:: console

    hacker@kali:~$ UA="Mozilla/5.0 (X11; Linux x86_64; rv:31.0)\
    >  Gecko/20100101 Firefox/31.0 Iceweasel/31.4.0"
    hacker@kali:~$ curl -L -s  --user-agent "$UA" http://www.independent.co.uk/ 2>&1 | \
    >     grep '<img' | grep -v 'independent.co.uk' | \
    >     egrep '(imrworldwide|quantserve)'
    <img src="//secure-uk.imrworldwide.com/cgi-bin/
        m?ci=uk-805619h&amp;cg=0&amp;cc=1&amp;ts=noscript"
    <img src="//pixel.quantserve.com/pixel/p-jAJ_WUYAnDzxn.gif" 
        border="0" height="1" width="1" alt="Quantcast"/>


Supercookie
  From `Supercookie <http://en.wikipedia.org/wiki/HTTP_cookie#Supercookie>`_:

    A "supercookie" is a cookie with an origin of a Top-Level Domain (such as .com) or a Public Suffix (such as .co.uk). It is important that supercookies are blocked by browsers, due to the security holes they introduce. If unblocked, an attacker in control of a malicious website could set a supercookie and potentially disrupt or impersonate legitimate user requests to another website that shares the same Top-Level Domain or Public Suffix as the malicious website. For example, a supercookie with an origin of .com, could maliciously affect a request made to example.com, even if the cookie did not originate from example.com. This can be used to fake logins or change user information.

    The Public Suffix List is a cross-vendor initiative to provide an accurate list of domain name suffixes changing. Older versions of browsers may not have the most up-to-date list, and will therefore be vulnerable to supercookies from certain domains.

    Supercookie (other uses)

    The term "supercookie" is sometimes used for tracking technologies that do not rely on HTTP cookies. Two such "supercookie" mechanisms were found on Microsoft websites: cookie syncing that respawned MUID (Machine Unique IDentifier) cookies, and ETag cookies. Due to media attention, Microsoft later disabled this code.

  Note: ETag (entity tag) is used for web cache validation and is stored by the browsers and returned when requesting the same resource. Tracking servers can return ETags and thus persist them on the browser. ETags should be flushed when the browser cache is cleared.

Zombie cookie
  a cookie automatically recreated by client-side scripts from other storage (flash storage or HTML5 local storage).


Microdata
=========

`WHATWG Microdata`_ and `W3C HTML Microdata`_ define HTML5's microdata. For gentler introductions see `“Distributed,” “Extensibility,” & Other Fancy Words <http://diveintohtml5.info/extensibility.html>`_ or `Extending HTML5 — Microdata <http://html5doctor.com/microdata/>`_.

From `Microdata`_:

  Microdata is a WHATWG HTML specification used to nest metadata within existing content on web pages. Search engines, web crawlers, and browsers can extract and process Microdata from a web page and use it to provide a richer browsing experience for users. Search engines benefit greatly from direct access to this structured data because it allows search engines to understand the information on web pages and provide more relevant results to users. Microdata uses a supporting vocabulary to describe an item and name-value pairs to assign values to its properties. Microdata is an attempt to provide a simpler[citation needed] way of annotating HTML elements with machine-readable tags than the similar approaches of using RDFa and microformats.

From `Microdata`_, here is a before-microdata & after-microdata example of data using schema.org's `Person <http://schema.org/Person>`_:

.. code-block:: html

  <section> Hello, my name is John Doe, I am a graduate research assistant at
  the University of Dreams.
  My friends call me Johnny. 
  You can visit my homepage at <a href="http://www.JohnnyD.com">www.JohnnyD.com</a>.
  I live at 1234 Peach Drive, Warner Robins, Georgia.</section>

With microdata it might be:

.. code-block:: html

  <section itemscope itemtype="http://schema.org/Person"> 
	  Hello, my name is 
	  <span itemprop="name">John Doe</span>, 
	  I am a 
	  <span itemprop="jobTitle">graduate research assistant</span> 
	  at the 
	  <span itemprop="affiliation">University of Dreams</span>. 
	  My friends call me 
	  <span itemprop="additionalName">Johnny</span>. 
	  You can visit my homepage at 
	  <a href="http://www.JohnnyD.com" itemprop="url">www.JohnnyD.com</a>. 
	  <section itemprop="address" itemscope itemtype="http://schema.org/PostalAddress">
		  I live at 
		  <span itemprop="streetAddress">1234 Peach Drive</span>,
		  <span itemprop="addressLocality">Warner Robins</span>,
		  <span itemprop="addressRegion">Georgia</span>.
	  </section>
  </section>

Extracting the microdata provides::

  Item
     Type: http://schema.org/Person
     name = John Doe
     jobTitle = graduate research assistant
     affiliation = University of Dreams
     additionalName = Johnny
     url = http://www.johnnyd.com/
     address = Item(1)
  Item 1
     Type: http://schema.org/PostalAddress
     streetAddress = 1234 Peach Drive
     addressLocality = Warner Robins
     addressRegion = Georgia

By choosing schemas from `schema.org <http://schema.org/>`_ we take advantage of:

  This site provides a collection of schemas that webmasters can use to markup HTML pages in ways recognized by major search providers, and that can also be used for structured data interoperability (e.g. in JSON). Search engines including Bing, Google, Yahoo! and Yandex rely on this markup to improve the display of search results, making it easier for people to find the right Web pages. 

See `Getting started with schema.org using Microdata <http://schema.org/docs/gs.html>`_.


Web Storage
===========

The closest to cookies is `Web storage`_, which was originally part of the HTML5 spec but now has it's own `W3C Web Storage`_ recommendation. The `WHATWG Web storage <https://html.spec.whatwg.org/multipage/webstorage.html#webstorage>`_ is a good introduction, as is `The Past, Present & Future of Local Storage for Web Applications <http://diveintohtml5.info/storage.html>`_.

Web storage is a hash of (string key, string value) pairs separated into localStorage (which persists and is available across multiple tabs) and sessionStorage (with a lifetime of the tab or window). Additionally, storage events can trigger callbacks to event listeners which can react to storage changes.

Each top-level browsing context has a unique set of session storage areas, one for each origin. The localStorage object provides a Storage object for an origin. Thus, web storage is protected by the same origin policy.


To see if the browser supports localStorage:

.. code-block:: javascript

  function supports_html5_storage() {
    try {
      return 'localStorage' in window && window['localStorage'] !== null;
    } catch (e) {
      return false;
    }
  }

Or you can use the `Modernizr <http://modernizr.com/>`_ or `jStorage - store data locally with JavaScript <http://www.jstorage.info/>`_ libraries.


The localStorage interface is very simple:

.. code-block:: javascript

  localStorage.clear()
  localStorage.getItem(key)
  localStorage.removeItem(key)
  localStorage.setItem(key, value)
  localStorage.key(i)
  localStorage.length()

A storage event listener can be added via:

.. code-block:: javascript

  if (window.addEventListener) {
    window.addEventListener("storage", handle_storage, false);
  } else {
    window.attachEvent("onstorage", handle_storage);
  };

The event can be coded like:

.. code-block:: javascript

  function handle_storage(e) {
    if (!e) { e = window.event; }
    // process the event
  }

The returned StorageEvent object has the key, oldvalue, newvalue, and url of the page that triggered the change.

localStorage has a default 5 MB per origin limit which can be disabled by a user or administrator. It works offline, can hook into browser events, has less overhead than cookies, with more space than cookies. Developers control when or if the data are sent to the server. The data doesn't expire and might not be deleted when history is cleared.

`W3C Web Storage 6 Privacy <http://www.w3.org/TR/webstorage/#privacy>`_ contains some optional suggestions for improving privacy.


Web SQL
=======

From `Web SQL Database <http://en.wikipedia.org/wiki/Web_SQL_Database>`_:

  The W3C Web Applications Working Group ceased working on the specification in November 2010, citing a lack of independent implementations (i.e., the use of a database system other than SQLite as the backend) as the reason the specification could not move forward to become a W3C Recommendation.

  One potential alternative storage standard is IndexedDB.


IndexedDB
=========

`W3C Indexed Database API`_ is not part of HTML5 but is a separate W3C recommendation. From `Wikipedia Indexed Database API <http://en.wikipedia.org/wiki/Indexed_Database_API>`_:

  The Indexed Database API, or IndexedDB (formerly WebSimpleDB), is a proposed web browser standard interface for a local database of records holding simple values and hierarchical objects. IndexedDB was initially proposed by Oracle in 2009.

  IndexedDB could be used for browser implemented functions, such as bookmarks, as well as web applications, such as email. An open-source reference implementation of the Indexed Database API exists for testing and experimentation purposes.

For an example of IndexedDB see `Using IndexedDB <https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API/Using_IndexedDB>`_ (with `IndexedDB Demo: storing blobs, e-publication example <https://mdn.mozillademos.org/en-US/docs/Web/API/IndexedDB_API/Using_IndexedDB$samples/Full_IndexedDB_example?revision=723661>`_). Or if you like reference-like documentation, consult `IndexedDB <https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API>`_.

