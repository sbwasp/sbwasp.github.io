.. include:: /pentest_links.txt

.. _Forking a Repository: https://confluence.atlassian.com/display/BITBUCKET/Forking+a+Repository
.. _Forking Workflow: https://www.atlassian.com/git/tutorials/comparing-workflows/forking-workflow
.. _Making a Pull Request: https://www.atlassian.com/git/tutorials/making-a-pull-request

****************************
Contributing to this website
****************************

Using bitbucket & git to make changes
=====================================

Create a `bitbucket`_ account
-----------------------------

To contribute, create a (free) `bitbucket`_ account, then request to be added to the pentest_meetup team (giving read access to https://bitbucket.org/bitbender/pentest-meetup.git).

Forking workflow with pull requests
-----------------------------------

pentest-meetup follows `Getting Git Right`_'s collaboration model `Forking Workflow`_ with the public repository https://bitbucket.org/bitbender/pentest-meetup.git. Follow `Forking a Repository`_'s "How to Fork a Repository" to fork the public repository. You can periodically keep in sync with the public repository by following `Forking a Repository`_'s "Using the Bitbucket GUI to sync your fork to the original repo".

`Git Branching and Forking in the Enterprise: Why Fork? <http://blogs.atlassian.com/2013/05/git-branching-and-forking-in-the-enterprise-why-fork/>`_ explains "Forks have won the Open Source workflow choice award":

  Anybody can fork an open project and the original author does not incur in penalties or burdens because of it, the operation is transparent. He will potentially receive feedback or improvements in the form of pull requests but thatâ€™s it.

The actual fork does not point to the original public repository as it's origin: it thinks it's "the" repo. So how does the fork stay in sync? See `Git Forks And Upstreams: How-to and a cool tip <http://blogs.atlassian.com/2013/07/git-upstreams-forks/>`_. When the contributor clones their fork, their fork clone origin naturally enough points to the fork. But the contributor manually adds the public repository as an upstream repository, allowing the contributor to pull down the upstream changes to their local fork clone and push them up to the fork.

It's up to the public repository maintainer to pull the fork's branch and incorporate it into the public repository.

Making changes in a branch
--------------------------

Assume "user" wants to make a change to the public repository. First they clone their own fork of the public repository, add the public repository as an upstream, and sync up with the latest changes:

.. code-block:: bash

  # clone sets repository origin to user/pentest-meetup.git
  git clone https://user@bitbucket.org/user/pentest-meetup.git myclone
  cd myclone
  # add remote repository to track public repository
  git remote add upstream https://bitbucket.org/bitbender/pentest-meetup.git
  # make sure up-to-date with public repository
  git pull upstream master
  git push origin master

Next create a branch related to the change you are planning to make (here, python-unicode:

.. code-block:: bash

  git checkout -b python-unicode
  # Edit the source files
  git commit -a -m "20150113 - scripting - add Unicode"

If you're done you want to incorporate any changes in the upstream master:

.. code-block:: bash

  git checkout python-unicode
  git pull --rebase upstream master
  git push origin python-unicode
  git push origin master

Creating a pull request
-----------------------

Follow "Step 5. Create a pull request" in `Fork a Repo, Compare Code, and Create a Pull Request <https://confluence.atlassian.com/display/BITBUCKET/Fork+a+Repo,+Compare+Code,+and+Create+a+Pull+Request>`_. It's now up to the public repository maintainer to pull the branch and apply it to the public repository.

Working with a pull request
---------------------------

Follow `Work with pull requests <https://confluence.atlassian.com/display/BITBUCKET/Work+with+pull+requests>`_. After the pull request succeeds the fork can be updated to reflect the public repository change:

.. code-block:: bash

  git checkout master
  git pull upstream master
  git push origin master


Toy collaboration example using :program:`git`
----------------------------------------------

Here we show a collaboration example with a public repo managed by the maintainer and updated by 2 collaborators (collab1 & collab2). The repository maintainer creates the repo and adds :file:`contents.txt` with contents "line 1", ... , "line 5". Then collab1 & collab2 both fork the public repository to initiate a change. To complicate matters the public repository maintainer adds a "line 6" to :file:`contents.txt`. Then collab1 creates branch1 for their change, adds line "CHANGE1" to :file:`contents.txt`, submits a pull request for FORK1/branch1 which is accepted by the maintainer. collab2 does something a little different: creates 2 commits and reset is used to reduce it to 1 commit. So collab2 creates branch2 for their changes, adds lines "CHANGE2a" & "CHANGE2b" to :file:`contents.txt` in separate commits, rebases & corrects the conflict between "CHANGE1" and "CHANGE2", then uses reset to get to just 1 commit added, then submits a pull request for FORK2/branch2 which is accepted by the maintainer.

.. code-block:: bash

  # define directories
  EXAMPLE_DIR=$HOME/work/example
  PUBLIC=$EXAMPLE_DIR/public.git
  MAINTAINER=$EXAMPLE_DIR/maintainer
  FORK1=$EXAMPLE_DIR/FORK1.git
  FORK2=$EXAMPLE_DIR/FORK2.git
  CHANGE1=change1
  CHANGE2=change2
  # branches for change1/2, respectively
  BRANCH1=branch1
  BRANCH2=branch2

  mkdir -p $EXAMPLE_DIR
  rm -rf $EXAMPLE_DIR/*
  cd $EXAMPLE_DIR

  # create a shared, bare repo
  # bare repo lacks working directory
  #   - only the .git directory
  git init --bare $PUBLIC

  # maintainer creates initial content "line 1", ..., "line 5"
  git clone $PUBLIC $MAINTAINER
  cd $MAINTAINER
  for l in 1 2 3 4 5; do
    echo "line $l" >> content.txt
  done
  git add .
  git commit -m 'initial commit'
  git push origin master
  cd ..

  # create forks FORK1, FORK2
  #   fork =/= clone
  cp -r $PUBLIC $FORK1
  cp -r $PUBLIC $FORK2

  # update public so forks are out of sync
  cd $MAINTAINER
  echo "line 6" >> content.txt
  git commit -a -m 'second commit'
  git push
  cd ..

  # FORK1 starts change1
  git clone $FORK1 $CHANGE1
  cd $CHANGE1
  # clone points to $FORK1 but not $PUBLIC, so ...
  git remote add upstream $PUBLIC
  # get current with upstream ("line 6")
  git fetch upstream master
  git checkout master
  git pull upstream master
  git push origin master
  cd ..

  # FORK2 sets up $CHANGE2
  git clone $FORK2 $CHANGE2
  cd $CHANGE2
  # clone points to $FORK2 but not $PUBLIC, so ...
  git remote add upstream $PUBLIC
  # get current with upstream ("line 6")
  git fetch upstream master
  git checkout master
  git pull upstream master
  git push origin master
  cd ..

  # FORK1 sets up $CHANGE1 in $BRANCH1 and rebases to upstream before pull
  cd $CHANGE1
  git checkout -b $BRANCH1
  echo "CHANGE1" >> content.txt
  git add .
  git commit -m "CHANGE1"
  # ready to release
  # so FORK1 rebase to latest upstream
  git checkout master
  git pull upstream master
  git push origin master
  git checkout $BRANCH1
  git rebase master
  git push origin $BRANCH1
  cd ..

  # offline make a pull request
  # then public maintainer merges in the changes as follows
  cd $MAINTAINER
  git checkout master
  git pull
  git remote add FORK1 $FORK1
  git fetch FORK1
  git branch -f $BRANCH1 FORK1/$BRANCH1
  git checkout $BRANCH1
  git rebase master
  git checkout master
  git merge $BRANCH1
  git push
  git branch -D $BRANCH1
  git remote rm FORK1
  cd ..

  # now repeat above for $CHANGE2
  #   there is a conflict that has to be manually resolved
  #   and we're going to use reset to reduce to "single commit"
  #     alternatively could have used "rebase -i"
  # this is as messy as it gets

  # FORK2 sets up $CHANGE2 in $BRANCH2 and rebases to upstream before pull
  cd $CHANGE2
  git checkout -b $BRANCH2
  echo "CHANGE2a" >> content.txt
  git add .
  git commit -m "CHANGE2a"
  echo "CHANGE2b" >> content.txt
  git add .
  git commit -m "CHANGE2b"
  # ready to release
  # so FORK2 rebase to latest upstream
  git checkout master
  git pull upstream master
  git push origin master
  git tag START
  git checkout $BRANCH2
  git rebase master
  # after you save the file to change commits to 
  # fails due to not having CHANGE1, so fix and continue
  sed -i -e '/^<<<<<<< HEAD$/d;/^=======$/d;/^>>>>>>> /d' content.txt
  git add --all
  git rebase --continue
  # reset to START for "single commit"
  #   NOTE: this will overwrite BRANCH2 history in FORK2
  #         so this assumes it is your personal fork
  git reset START
  git add --all
  git commit -m "CHANGE2"
  git tag -d START
  # rebase means needs --force to push
  git push -f origin $BRANCH2
  cd ..

  # offline make a pull request
  # then public maintainer does merges in the changes if accepted
  cd $MAINTAINER
  git checkout master
  git pull
  git remote add FORK2 $FORK2
  git fetch FORK2
  git branch -f $BRANCH2 FORK2/$BRANCH2
  git checkout $BRANCH2
  git rebase master
  git checkout master
  git merge $BRANCH2
  git push
  git branch -D $BRANCH2
  git remote rm FORK2
  cd ..

Sphinx conventions
==================

