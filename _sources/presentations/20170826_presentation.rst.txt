.. include:: /pentest_links.txt


****************************************
2017-08-26 Complexity, Cookies vs Tokens
****************************************


Complexity
==========

Complexity helps make things insecure and most of computing is complex.

Consider `Firefox 54 finally goes multiprocess, eight years after work began <https://arstechnica.com/information-technology/2017/06/firefox-multiple-content-processes/>`_ and `HTTPS on Stack Overflow: The End of a Long Road <https://nickcraver.com/blog/2017/05/22/https-on-stack-overflow/>`_ which took approximately 4 years.

Then consider IPv6 and the likelyhood of IPv6 conversions having misconfigurations (like forgetting that IPv6 firewalls need sepearate rules for IPv6 traffic).

Complexity is a pentester's best friend.


Cookies vs Tokens
=================


Cookies
-------

See :ref:`cookies_data` for a general introduction to cookies.

The upshot is that cookies are data first created on the server and passed to the client via the "Set-Cookie:" HTTP header, which is subsequently returned by the client to the server via the "Cookie:" HTTP header. The server can modify the value in a later "Set-Cookie:" and that modified value will be returned in subsequent "Cookie:" HTTP headers. The cookie meaning is determined by the server.

The key point here is that cookies are generally created by the server that uses it.


Tokens
------

Tokens in general
^^^^^^^^^^^^^^^^^

"Token" in computing has many different meanings, but in this case we mean `Access token <https://en.wikipedia.org/wiki/Access_token>`_:

  An access token is an object encapsulating the security identity of a process or thread. A token is used to make security decisions and to store tamper-proof information about some system entity. While a token is generally used to represent only security information, it is capable of holding additional free-form data that can be attached while the token is being created.

  An access token is generated by the logon service when a user logs on to the system and the credentials provided by the user are authenticated against the authentication database. The authentication database contains credential information required to construct the initial token for the logon session, including its user id, primary group id, all other groups it is part of, and other information.

Very different from a cookie, the token can be generated by a 3rd party (like when you can use a Google account to log into Bitbucket) and need not be stored as a cookie.


 While tokens can be created by the server and stored in cookies, tokens can be created by 3rd parties and not stored as cookies.

JWT tokens
^^^^^^^^^^

From `Wikipedia JSON Web Token <https://en.wikipedia.org/wiki/JSON_Web_Token>`_:

  JSON Web Token (JWT) is a JSON-based open standard (RFC 7519) for creating access tokens that assert some number of claims. For example, a server could generate a token that has the claim "logged in as admin" and provide that to a client. The client could then use that token to prove that it is logged in as admin. The tokens are signed by the server's key, so the client and server are both able to verify that the token is legitimate. The tokens are designed to be compact, URL-safe and usable especially in web browser single sign-on (SSO) context. JWT claims can be typically used to pass identity of authenticated users between an identity provider and a service provider, or any other type of claims as required by business processes. The tokens can also be authenticated and encrypted.

From `Introduction to JSON Web Tokens <https://jwt.io/introduction/>`_:

* JSON Web Token (JWT) is an open standard (RFC 7519) that defines a compact and self-contained way for securely transmitting information between parties as a JSON object.

* JWT looks like xxxxx.yyyyy.zzzzz (see `JWT Debugger <https://jwt.io/>`_ to encode/decode JWT).

  * It uses Base64URL encoding as defined in `RFC 4648 Base 64 Encoding with URL and Filename Safe Alphabet <https://tools.ietf.org/html/rfc4648#section-5>`_.

    Standard ``base64`` uses '+', '/', and '=' which would require percent-encoding hexadecimal. In base64url they are replaced with '-', '_', and nothing (padding skipped as the alternative '.' is used to separate the 3 JWT token fields). Alternatively, use ``base64url`` from the basez package.

    The JSON strings are canonicalized (squished together) prior to base64url encoding. In ``bash`` this Perl utility works: ``cat JSONFILE | json_pp -json_opt canonical``. In ``python3`` this works: ``base64.b64encode(JSONSTRING.encode('UTF-8'), altchars=b'-_').decode('UTF-8').rstrip('=')``.

    Here's a command line example:

    .. code-block:: bash

      cat > header.txt <<'EOF'
      {
        "alg": "HS256",
        "typ": "JWT"
      }
      EOF
      # Canonicalized it looks like:
      cat header.txt | json_pp -json_opt canonical

      # base64url of the above is eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9
      cat header.txt | base64 | tr '+/' '-_' | tr -d '=' # wrong
      cat header.txt | json_pp -json_opt canonical | base64 | tr '+/' '-_' | tr -d '='  # correct
      cat header.txt | json_pp -json_opt canonical | base64url  # correct

    Here's a python example:

    .. code-block:: bash

      cat > json-canonical.py <<'EOF'
      import json
      from argparse import ArgumentParser

      parser = ArgumentParser(description="""\
      JSON canonicalization
      """)
      parser.add_argument('jsonfile', help="""Input JSON from the file.""")
      args = parser.parse_args()

      with open(args.jsonfile, 'r', encoding="utf-8") as fp:
          print(json.dumps(json.load(fp), separators=(",",":")), end="")
      EOF

      # Demo in canonicalizes the same as json_pp
      python3 json-canonical.py header.txt

      # Now convert to base64url
      cat > base64url.py <<'EOF'
      import sys
      import base64
      print(base64.b64encode(sys.stdin.read().encode("UTF-8"), altchars=b"-_").decode("UTF-8").rstrip("="))
      exit()
      EOF

      python3 json-canonical.py header.txt | python3 base64url.py


  * xxxxx = header

    This typcially defines the hashing algorithm & token type: '{"alg":"HS256","typ":"JWT"}' encoded via base64url.

  * yyyyy = payload

    "The second part of the token is the payload, which contains the claims. Claims are statements about an entity (typically, the user) and additional metadata. There are three types of claims: reserved, public, and private claims."

  * zzzzz = signature

    "The signature is used to verify that the sender of the JWT is who it says it is and to ensure that the message wasn't changed along the way."

  * JWT tokens are **signed, not encrypted**: `RFC 7516 JSON Web Encryption (JWE) <https://tools.ietf.org/html/rfc7516>`_.

* The JWT token is usually sent in the HTTP "Authorization:" header like this:

  ``Authorization: Bearer <token>``

  Note that this is stateless in that the server need not save user state in memory as the token contains the information needed.


Cookies vs Tokens
-----------------

From `Cookies vs Tokens: The Definitive Guide <https://auth0.com/blog/cookies-vs-tokens-definitive-guide/>`_ start with the image `Cookie-Based and Token-Based Auth <https://cdn.auth0.com/blog/cookies-vs-tokens/cookie-token-auth.png>`_:

  Cookie based authentication is stateful. This means that an authentication record or session must be kept both server and client-side. The server needs to keep track of active sessions in a database, while on the front-end a cookie is created that holds a session identifier, thus the name cookie based authentication.

  Token-based authentication is stateless. The server does not keep a record of which users are logged in or which JWTs have been issued. Instead, every request to the server is accompanied by a token which the server uses to verify the authenticity of the request. The token is generally sent as an addition Authorization header in form of Bearer {JWT}, but can additionally be sent in the body of a POST request or even as a query parameter.

  The back-end does not need to keep a record of tokens. Each token is self-contained, containing all the data required to check its validity as well as convey user information through claims.

  The server's only job then, becomes to sign tokens on a successful login request and verify that incoming tokens are valid. In fact, the server does not even need to sign tokens. Third party services such as Auth0 can handle the issuing of tokens and then the server only needs to verify the validity of the token.

The chief considerations for tokens are:

* Size - too much data makes them large

* Storage

  * Local storage is sandboxed to a domain (not accessible by subdomains). This protects against XSRF.

  * Cookies are limited to 4 kb and do not protect against XSRF, though setting a cookie to HttpOnly protects against XSS via JavaScript.

  * Session storage which disappears when the browser closes.


Authentication examples at GitHub
---------------------------------

We use GitHub for examples: see `platform-samples <https://github.com/github/platform-samples>`_.

We'll use GitHub's `REST API v3 <https://developer.github.com/v3/guides/getting-started/>`_ to illustrate authentication. See `REST API v3 Libraries <https://developer.github.com/v3/libraries/>`_ for language-specific libraries.

.. note::

  GitHub `Apps <https://developer.github.com/apps/>`_ notes that "GitHub Apps are only compatible with the REST API v3 at this time." So there is limited coverage of the `GraphQL API v4 <https://developer.github.com/v4/>`_.

From `REST API v3 Getting Started <https://developer.github.com/v3/guides/getting-started/>`_:

  While convenient, Basic Authentication isn't ideal because you shouldn't give your GitHub username and password to anyone. Applications that need to read or write private information using the API on behalf of another user should use `OAuth <https://developer.github.com/apps/building-integrations/setting-up-and-registering-oauth-apps/>`_.

  Instead of usernames and passwords, OAuth uses tokens. Tokens provide two big features:

  * **Revokable access**: users can revoke authorization to third party apps at any time

  * **Limited access**: users can review the specific access that a token will provide before authorizing a third party app

Also, note that if you use GitHub 2FA with your user account, then your basic authentication ``curl`` request will return "401 Unauthorized" and you'll need to get the 2FA OTP code and repeat the request. Unfortunately this is true for every request, which will essentially force a switch to using an OAuth-like GitHub personal access token which can be used in lieu of your password in basic authentication, or as a token (see below). (Note: some API endpoints like *https://api.github.com/authorizations* requires the use of basic authentication with the password.)

.. code-block:: bash

  curl -u "$U:$PASS" -H "X-GitHub-OTP: 2FA_OTP" ...


Unauthenticated access
^^^^^^^^^^^^^^^^^^^^^^

Unauthenticated access is subject to `Rate Limiting <https://developer.github.com/v3/#rate-limiting>`_ of 60 requests/hour. To see your limit:

.. code-block:: bash

  curl -i https://api.github.com/rate_limit
  curl -s https://api.github.com/rate_limit | jq ' { limit: .rate.limit, remaining: .rate.remaining }'
  # {
  #   "limit": 60,
  #   "remaining": 58
  # }
  # Rate "reset" field is UTC epoch seconds
  date -d @$(curl -s https://api.github.com/rate_limit | jq '.rate.reset')
  # Thu Aug 24 20:51:09 UTC 2017

There's lots of things an unauthenticated user can access, but since the data is returned in JSON it's difficult to process:

.. code-block:: bash

  U="pentest-meetup"
  O="sbwasp"

  curl -i https://api.github.com/users/$U
  curl https://api.github.com/users/$O
  curl https://api.github.com/users/sbwasp/repos


Basic authentication
^^^^^^^^^^^^^^^^^^^^

Here's an example of `RFC 2617 HTTP Authentication: Basic and Digest Access Authentication <http://www.ietf.org/rfc/rfc2617.txt>`_ (``-u 'USER:PASSWORD'``, where you'll be prompted for the password if not provided). For GitHub see `Basic Authentication <https://developer.github.com/v3/auth/#basic-authentication>`_.

.. code-block:: bash

  U="pentest-meetup"
  EMAIL="$U@bitbender.org"
  # Leading space keeps line from history:
   PASS=$'YOUR_PASSWORD'

  # Basic Auth bumps hourly limit to 5000
  curl -i -u "$U:$PASS" https://api.github.com/rate_limit

  curl -v -u "$U:$PASS" 'https://api.github.com/users/pentest-meetup/orgs'
  curl -v -u "$U:$PASS" 'https://api.github.com/users/sbwasp/orgs'

Authenticated requests can use GraphQL (see `GitHub Migrating from REST to GraphQL <https://developer.github.com/v4/guides/migrating-from-rest/>`_ and `GraphQL API v4 Using the Explorer <https://developer.github.com/v4/guides/using-the-explorer/>`_):

.. code-block:: bash

  cat > user.gql <<'EOF'
  { "query": "query {
      viewer {
        login
        name
      }
    }"
  }
  EOF
  curl -u "$U:$PASS" --data @user.gql 'https://api.github.com/graphql'
  # {"data":{"viewer":{"login":"pentest-meetup","name":null}}}


  cat > repo_desc.gql <<'EOF'
  { "query": "query {
      repository(owner:\"sbwasp\", name:\"sbwasp.github.io\") {
        description
      }
    }"
  }
  EOF
  curl -u "$U:$PASS" --data @repo_desc.gql 'https://api.github.com/graphql'
  # {"data":{"repository":{"description":"South Bay WASP Website"}}}


Access token
^^^^^^^^^^^^

GitHub has several different kinds of tokens:

personal access token
  Generate a personal access token at `Personal access tokens <https://github.com/settings/tokens>`_. "Personal access tokens function like ordinary OAuth access tokens. They can be used instead of a password for Git over HTTPS, or can be used to `authenticate to the API over Basic Authentication <https://developer.github.com/v3/auth/#basic-authentication>`_."


OAuth token
  Like the personal access token, the OAuth token can be used for basic authentication. In addition it's an OAuth token that can be used in the HTTP header ``Authorization: token OAUTH-TOKEN``.

  To create an OAuth token follow the instructions at *Non-Web Application Flow* at `About authorization options for OAuth Apps <https://developer.github.com/apps/building-integrations/setting-up-and-registering-oauth-apps/about-authorization-options-for-oauth-apps/>`_.

Since we do not have an OAuth application, we created an "SBWasp Meetup Token Example" with the following scopes: public_repo, gist, notifications, and user:email. Note that the token is shown only once (copy it and save). Using ``curl -u "$U:$PASS" https://api.github.com/authorizations`` gives the following token information:

.. code-block:: json

  [
    {
      "id": 123622097,
      "url": "https://api.github.com/authorizations/123622097",
      "app": {
        "name": "SBWasp Meetup Token Example",
        "url": "https://developer.github.com/v3/oauth_authorizations/",
        "client_id": "00000000000000000000"
      },
      "token": "",
      "hashed_token": "1234567891123456789212345678931234567894123456789512345678961234",
      "token_last_eight": "43482ab6",
      "note": "SBWasp Meetup Token Example",
      "note_url": null,
      "created_at": "2017-08-24T17:59:35Z",
      "updated_at": "2017-08-24T17:59:35Z",
      "scopes": [
        "gist",
        "notifications",
        "public_repo",
        "user:email"
      ],
      "fingerprint": null
    },
  ]

Use the token with basic authentication, then as ``Authorization: token PERSONALTOKEN``:

.. code-block:: bash

  # Identical basic authentication results using either TOKEN or PASS
   TOKEN='substitute the token'
  curl -i -u "$U:$TOKEN" https://api.github.com/authorizations
  curl -u "$U:$PASS" https://api.github.com/authorizations
  # personal token via "Authorization: token ..."
  curl -i -H "Authorization: token $TOKEN" https://api.github.com/users/sbwasp/orgs

  # personal token as token with GraphQL
  cat > repo_desc.gql <<'EOF'
  { "query": "query {
      repository(owner:\"sbwasp\", name:\"sbwasp.github.io\") {
        description
      }
    }"
  }
  EOF
  curl -H "Authorization: token $TOKEN" --data @repo_desc.gql 'https://api.github.com/graphql'
