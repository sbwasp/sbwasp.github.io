.. include:: /pentest_links.txt


**********************************************************
2017-12-30 gohttp, hardening C/C++, Linux waitid() exploit
**********************************************************


Links and updates this week
===========================


Links around the web
--------------------


Cloud links
^^^^^^^^^^^

#. `HTML 5.2 is done, HTML 5.3 is coming <https://www.w3.org/blog/2017/12/html-5-2-is-done-html-5-3-is-coming/>`_ including `Payment Request API <https://www.w3.org/TR/payment-request/>`_, `Content Security Policy Level <https://www.w3.org/TR/CSP3/>`_, and `Accessible Rich Internet Applications (WAI-ARIA) 1.1 <https://www.w3.org/TR/wai-aria/>`_

#. `DDoS Attacks in Cloud Computing: Issues, Taxonomy, and Future Directions <https://arxiv.org/abs/1512.08187>`_

#. `Funny Or Die, Bustle And A Bunch Of Other Publishers Unwittingly Bought Fake Traffic <https://www.buzzfeed.com/craigsilverman/these-publishers-bought-millions-of-website-visits-they?utm_term=.gcNyA0awEk#.mh4g8Rjn7E>`_


Tech
^^^^

#. `Top 10 Single Board Computers Introduced in 2017 <https://www.eetimes.com/document.asp?doc_id=1332763>`_

#. `Google’s voice-generating AI is now indistinguishable from humans <https://qz.com/1165775/googles-voice-generating-ai-is-now-indistinguishable-from-humans/>`_ and `Natural TTS Synthesis by Conditioning WaveNet on Mel Spectrogram Predictions <https://arxiv.org/abs/1712.05884>`_

#. `Intel® Architecture Memory Encryption Technologies Specification <https://software.intel.com/sites/default/files/managed/a5/16/Multi-Key-Total-Memory-Encryption-Spec.pdf>`_

#. `Passive Fingerprinting of HTTP/2 Clients <https://www.blackhat.com/docs/eu-17/materials/eu-17-Shuster-Passive-Fingerprinting-Of-HTTP2-Clients-wp.pdf>`_

#. `How "expensive" is crypto anyway? <https://blog.cloudflare.com/how-expensive-is-crypto-anyway/amp/>`_

#. `Why TLS 1.3 isn't in browsers yet <https://blog.cloudflare.com/why-tls-1-3-isnt-in-browsers-yet/>`_


Tools
^^^^^

#. `Linux Expl0rer <https://github.com/intezer/linux-explorer>`_ - live forensics toolbox for Linux endpoints written in Python & Flask

#. `slurp <https://github.com/bbb31/slurp>`_ - Enumerates S3 buckets manually or via `certstream <https://certstream.calidog.io/>`_

#. `Undefined vs Unsafe in Rust <https://manishearth.github.io/blog/2017/12/24/undefined-vs-unsafe-in-rust/>`_

#. `UpGuard Extgernal Risk Assessment <https://app.upguard.com/webscan>`_

#. `Cracking Encrypted PDFs – Part 1 <https://blog.didierstevens.com/2017/12/26/cracking-encrypted-pdfs-part-1/>`_, `Cracking Encrypted PDFs – Part 2 <https://blog.didierstevens.com/2017/12/27/cracking-encrypted-pdfs-part-2/>`_, `Cracking Encrypted PDFs – Part 3 <https://blog.didierstevens.com/2017/12/28/cracking-encrypted-pdfs-part-3/>`_, and the yet-to-be-published conclusion.

#. `Which Languages Are Bug Prone <http://www.i-programmer.info/news/98-languages/11184-which-languages-are-bug-prone.html>`_

#. `Why I started to use Golang more than Python or Ruby? <https://www.whitesmith.co/blog/why-i-started-to-use-golang-more-than-python-or-ruby/>`_

#. `Using Go Templates <https://blog.gopheracademy.com/advent-2017/using-go-templates/>`_

#. `Tensorflow and Go <https://blog.gopheracademy.com/advent-2017/tensorflow-and-go/>`_


Study links
^^^^^^^^^^^

#. `Black Hat Europe 2017 <https://www.youtube.com/playlist?list=PLH15HpR5qRsXtpLirwYHPWyqcEFPbr-uB>`_

#. `Concise (Post-Christmas) Cryptography Challenges <https://blog.cloudflare.com/concise-post-christmas-cryptographic-challenges/>`_

#. `An Introduction to SMB for Network Security Analysts <https://401trg.pw/an-introduction-to-smb-for-network-security-analysts/>`_

#. `Hardening C/C++ Programs Part I – Stack Protector <http://www.productive-cpp.com/hardening-cpp-programs-stack-protector/>`_ and `Hardening C/C++ Programs Part II – Executable-Space Protection and ASLR <http://www.productive-cpp.com/hardening-cpp-programs-executable-space-protection-address-space-layout-randomization-aslr/>`_

#. `Netflix: What Happens When You Press Play? <http://highscalability.com/blog/2017/12/11/netflix-what-happens-when-you-press-play.html>`_

#. `Fusion <https://exploit-exercises.com/fusion/>`_

   #. `Fusion – Level 05 solution <http://arielkoren.com/blog/2017/06/14/fusion-level05-solution/>`_

   #. `Fusion – Level 06 solution <http://arielkoren.com/blog/2017/11/14/fusion-level-06-solution/>`_

#. `Let's hand write DNS messages <https://routley.io/tech/2017/12/28/hand-writing-dns-messages.html>`_


Privacy links
^^^^^^^^^^^^^

#. `No boundaries for user identities: Web trackers exploit browser login managers <https://freedom-to-tinker.com/2017/12/27/no-boundaries-for-user-identities-web-trackers-exploit-browser-login-managers/>`_ and `Web Trackers Exploit Flaw in Browser Login Managers to Steal Usernames <https://www.bleepingcomputer.com/news/security/web-trackers-exploit-flaw-in-browser-login-managers-to-steal-usernames/>`_

#. `Measuring and Disrupting Anti-Adblockers Using Differential Execution Analysis <http://homepage.divms.uiowa.edu/~mshafiq/files/adblock-ndss2018.pdf>`_ and `Thousands of major sites are taking silent anti-ad-blocking measures <https://techcrunch.com/2017/12/27/thousands-of-major-sites-are-taking-silent-anti-ad-blocking-measures/>`_

#. `That Game on Your Phone May Be Tracking What You’re Watching on TV <https://www.nytimes.com/2017/12/28/business/media/alphonso-app-tracking.html>`_

   #. `Is Your Vizio Television Spying on You? What to Know <https://www.nytimes.com/2017/02/07/business/vizio-television-vizio-collected-viewers-habits-consent.html>`_

   #. `FTC Issues Warning Letters to App Developers Using ‘Silverpush’ Code <https://www.ftc.gov/news-events/press-releases/2016/03/ftc-issues-warning-letters-app-developers-using-silverpush-code>`_

   #. `For Marketers, TV Sets Are an Invaluable Pair of Eyes <https://www.nytimes.com/2017/02/25/business/media/tv-viewers-tracking-tools.html>`_


Legal/Political
^^^^^^^^^^^^^^^

#. `Internal FCC Report Shows Republican Net Neutrality Narrative Is False <https://motherboard.vice.com/en_us/article/vbympa/net-neutrality-fcc-inspector-general-report>`_

#. `Differential Pricing of Traffic in the Internet <https://arxiv.org/abs/1709.09334>`_


Hacking links
^^^^^^^^^^^^^

#. `Digmine Cryptocurrency Miner Spreading via Facebook Messenger <http://blog.trendmicro.com/trendlabs-security-intelligence/digmine-cryptocurrency-miner-spreading-via-facebook-messenger/>`_

#. `LastPass’ Authenticator app is not secure <https://hackernoon.com/lastpass-authenticator-app-is-not-secure-77b9743c3007>`_

#. `CVE-2017-7845 <https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-7845>`_ and `Using Thunderbird? Update if you haven’t already <https://arstechnica.com/information-technology/2017/12/mozilla-squashes-critical-thunderbird-bug/>`_

#. `Acoustic Attacks on HDDs Can Sabotage PCs, CCTV Systems, ATMs, More <https://www.bleepingcomputer.com/news/security/acoustic-attacks-on-hdds-can-sabotage-pcs-cctv-systems-atms-more/>`_ and `Acoustic Denial of Service Attacks on HDDs <https://arxiv.org/pdf/1712.07816.pdf>`_

#. `MoneyTaker: in pursuit of the invisible <https://www.group-ib.com/blog/moneytaker>`_

#. `Two Critical 0-Day Remote Exploits for vBulletin Forum Disclosed Publicly <https://thehackernews.com/2017/12/vbulletin-forum-hacking.html>`_ (`SSD Advisory – vBulletin routestring Unauthenticated Remote Code Execution <https://blogs.securiteam.com/index.php/archives/3569>`_ and `SSD Advisory – vBulletin cacheTemplates Unauthenticated Remote Arbitrary File Deletion <https://blogs.securiteam.com/index.php/archives/3573>`_)

#. `Chrome Extension with 100,000 Users Caught Pushing Cryptocurrency Miner <https://www.bleepingcomputer.com/news/security/chrome-extension-with-100-000-users-caught-pushing-cryptocurrency-miner/>`_


gohttp replacing Python http.server
-----------------------------------

``python3 -m http.server`` can simply serve a static website. To accomplish a similar task using go, see `gohttp: go simple http server <https://github.com/itang/gohttp>`_:

.. code-block:: bash
  :emphasize-lines: 1-2,4-

  go get -u github.com/itang/gohttp
  go install github.com/itang/gohttp/gohttp

  export PATH="$PATH:$HOME/go/bin"
  gohttp --help
  # cntrl-C
  gohttp -d=$HOME/Persistent/pentest/pentest-meetup/build/html


C/C++ stack protector
---------------------

This is based on `Hardening C/C++ Programs Part I – Stack Protector <http://www.productive-cpp.com/hardening-cpp-programs-stack-protector/>`_.

Here is 

.. code-block:: bash
  :emphasize-lines: 4,8-10,13,15,17
  :caption: stack_overflow.cpp
  :name: stack_overflow.cpp

  cat > stack_overflow.cpp <<'EOF'
  #include <cstring>

  void exploitable(char* bar)
  {
     char buffer[16];

     strcpy(buffer, bar); // String  'bar' is directly copied into the buffer.
                          // This will overwrite adjacent data on the stack when
                          // 'bar' is longer than 16 bytes (including null terminator).
  }

  int main(int argc, char** argv)
  {
     exploitable(argv[1]);  // User can pass a string of arbitrary length here.

     return 0;
  }
  EOF

.. code-block:: bash
  :emphasize-lines: 1-2,5-7,9-10,13-15

  # protect against alloca() and char arrays >= 8 bytes
  g++ -fstack-protector stack_overflow.cpp -o stack_overflow
  ./stack_overflow 0123456789  # Ok, string does not exceed buffer
  echo $?
  ./stack_overflow 0123456789012345678901234  # String too long for buffer!
  # *** stack smashing detected ***: ./stack_overflow terminated
  echo $?

  # protect against any array type or local frame refs
  g++ -fstack-protector-strong stack_overflow.cpp -o stack_overflow
  ./stack_overflow 0123456789  # Ok, string does not exceed buffer
  echo $?
  ./stack_overflow 0123456789012345678901234  # String too long for buffer!
  # *** stack smashing detected ***: ./stack_overflow terminated
  echo $?


C/C++ executable-space protection and ASLR
------------------------------------------

This is based on `Hardening C/C++ Programs Part II – Executable-Space Protection and ASLR <http://www.productive-cpp.com/hardening-cpp-programs-executable-space-protection-address-space-layout-randomization-aslr/>`_.


Some ELF background
^^^^^^^^^^^^^^^^^^^

See :ref:`elf-and-binutils` for ELF background.


Executable-space protection
^^^^^^^^^^^^^^^^^^^^^^^^^^^

Follow *Executable-space protection* in the hardening article above.


Address space layout randomization
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Follow *Address Space Layout Randomization* in the hardening article above.

For details about PLT (Procedure Linkage Table) and GOT (Global Offsets Table) see `PLT and GOT - the key to code sharing and dynamic libraries <https://www.technovelty.org/linux/plt-and-got-the-key-to-code-sharing-and-dynamic-libraries.html>`_. For even more detail about linking `search for "Linkers" at Airs <https://www.airs.com/blog/index.php?s=linkers>`_.

The code example from the article follows:

.. code-block:: bash
  :emphasize-lines: 1,10,17,21,24,27,29

  cat > main.cpp <<'EOF'
  double pi();

  int main()
  {
    return (int)pi();
  }
  EOF

  cat > shared.cpp <<'EOF'
  double pi()
  {
    return 3.14f;
  }
  EOF

  # Build and link shared library
  g++ -c -fPIC shared.cpp -o shared.o
  g++ -shared -fPIC shared.o -o libshared.so

  # Build and link main executable
  g++ -c -fPIE main.cpp -o main.o
  g++ -pie -fPIE main.o -L. -lshared -o main
  # Looks like shared library
  file main

  # Build and link main executable without PIE
  g++ main.o -L. -lshared -o main_no_pie
  # Looks like executable
  file main_no_pie


Exploits this week
==================


Linux kernel vulnerability CVE-2017-5123
----------------------------------------

We will not talk about `Escaping Docker container using waitid() – CVE-2017-5123 <https://www.twistlock.com/2017/12/27/escaping-docker-container-using-waitid-cve-2017-5123/>`_, but instead another exploit using CVE-2017-5123.

Some terms first:

SMAP (`Supervisor Mode Access Prevention <https://en.wikipedia.org/wiki/Supervisor_Mode_Access_Prevention>`_)
  a feature of some CPU implementations such as the `Intel <https://en.wikipedia.org/wiki/Intel>`_ `Broadwell <https://en.wikipedia.org/wiki/Broadwell_(microarchitecture)>`_ microarchitecture that allows `supervisor mode <https://en.wikipedia.org/wiki/Supervisor_mode>`_ programs to optionally set `user-space <https://en.wikipedia.org/wiki/User-space>`_ `memory mappings <https://en.wikipedia.org/wiki/Virtual_memory>`_ so that access to those mappings from supervisor mode will cause a trap. This makes it harder for `malicious programs <https://en.wikipedia.org/wiki/Malicious_software>`_ to "trick" the kernel into using `instructions <https://en.wikipedia.org/wiki/Instruction_(computer_science)>`_ or `data <https://en.wikipedia.org/wiki/Data>`_ from a user-space program.

  Supervisor Mode Access Prevention is designed to complement `Supervisor Mode Execution Prevention <https://en.wikipedia.org/wiki/Control_register#SMEP>`_ (SMEP), which was introduced earlier. SMEP can be used to prevent supervisor-mode code from unintentionally executing user-space code. SMAP extends this protection to reads and writes.

From `Exploiting CVE-2017-5123 with full protections. SMEP, SMAP, and the Chrome Sandbox! <https://salls.github.io/Linux-Kernel-CVE-2017-5123/>`_ a Linux kernel mod neglected to call ``access_ok(VERIFY_WRITE, ptr, sizeof(*ptr))`` prior to calling the ``unsafe_put_user()``:

  During system call handling, the kernel needs to be able to read and write to the memory of the process which invoked the system call. To do this the kernel has special functions such as copy_from_user, put_user, and others, which copy data to or from userland. On a very high level, put_user does approximately the following:

  .. code-block:: c
    :emphasize-lines: 1-2,4,6

    put_user(x, void __user *ptr)
        if (access_ok(VERIFY_WRITE, ptr, sizeof(*ptr)))
            return -EFAULT
        user_access_begin()
        *ptr = x
        user_access_end()

  In kernel version 4.13, the waitid syscall was updated to use unsafe_put_user, but the access_ok check was missing. The vulnerable code is shown below.

  .. code-block:: c
    :emphasize-lines: 18-25

    SYSCALL_DEFINE5(waitid, int, which, pid_t, upid, struct siginfo __user *,
                                      infop, int, options, struct rusage __user *, ru)
    {
        struct rusage r;
        struct waitid_info info = {.status = 0};
        long err = kernel_waitid(which, upid, &info, options, ru ? &r : NULL);
        int signo = 0;

        if (err > 0) {
            signo = SIGCHLD;
            err = 0;
            if (ru && copy_to_user(ru, &r, sizeof(struct rusage)))
                return -EFAULT;
            }
            if (!infop)
                return err;

            user_access_begin();
            unsafe_put_user(signo, &infop->si_signo, Efault);    <-    no access_ok call
            unsafe_put_user(0, &infop->si_errno, Efault);
            unsafe_put_user(info.cause, &infop->si_code, Efault);
            unsafe_put_user(info.pid, &infop->si_pid, Efault);
            unsafe_put_user(info.uid, &infop->si_uid, Efault);
            unsafe_put_user(info.status, &infop->si_status, Efault);
            user_access_end();
            return err;
    Efault:
            user_access_end();
            return -EFAULT;
    }

From the article:

  ... we’ll need to know the kernel base address for exploiting, so let’s get that first. A nice property of unsafe_put_user is that it won’t crash when accessing invalid memory addresses, and instead will just return -EFAULT. Thus, we can just keep guessing addresses where the kernel data section could be at until we get a different error code, then we know we found the kernel address, and can defeat KASLR.

There are a number of steps:

#. Determine address of kernel data section and heap using the ``unsafe_put_user`` return code.

#. Bypass SMAP by spraying the heap until no longer restricted by `seccomp <https://en.wikipedia.org/wiki/Seccomp>`_.

#. Find kernel physmap memory section containing alias (second virtual address mapped to the same physical memory as userpace memory). Involves randomly overwirting pages in physmap, then see if the userland page has changed. This can crash a random process.

#. Change the creds structure to become root, then remove the chroot. This involves pointing the task_struct's files pointer to the previously found kernel alias. Pointing the ioctl at ROP gadgets in the kernel allows creating arbitrary read and write primitives.

The exploit is not easy as:

  As a recap, we are currently quite limited in what we can do:

  * We can only write 0’s.
  * We write 24 bytes of 0’s and will clobber nearby memory.
  * We don’t have a great info leak. We can know where the kernel base is, where the heap is, but not where an object in the heap is.

Two exploits are described at `kernel-exploits/CVE-2017-5123 <https://github.com/salls/kernel-exploits/tree/master/CVE-2017-5123>`_. From `kernel-exploits/CVE-2017-5123/exploit_smap_bypass.c <https://github.com/salls/kernel-exploits/blob/master/CVE-2017-5123/exploit_smap_bypass.c>`_:

.. code-block:: c

  /****** overview of exploit ********
  waitid uses unsafe_put_user without checking access_ok,
  allowing the user to give a kernel address for infop and write over kernel memory.
  when given invalid parameters this just writes the following 32 bit integers
  0, 0, 0, _, 0, 0, 0
  (the 4th element is unchanged)
  inside the chrome sandbox we cannot fork (can only make threads)
  so we can only give invalid parameters to waitid and only write 0's to kernel memory,
  To exploit this in the presence of smap:
  I start out by iteratively calling waitid until we find the kernel's base address
  When it's found it will not return efault error from the syscall
  Now, I can only write 0's at this point, so I spray 10000 threads and attempt
  to write 0's over the beginning of the task struct to unset the seccomp flag
  This part is kind of unreliable and depends on the size of the task struct which
  changes based on cpu.
  If it succceeds, I now know where the task struct is and no longer have seccomp
  By shifting the location of the write and using the pid of the child process, I
  can now write 5 consecutive arbitrary non-zero bytes. So I can create an address
  with this bitmask 0xffffffffff000000
  Now to create data at such an address I use the physmap, a mirror of all userland
  pages that exists in kernel memory. Mmap a large amount of memory, try writing at
  various places in the physmap until we see userland memory change. Then mlock that
  page.
  With controlled data in the kernel, I use the 5 byte write described above to change
  our task->files to point at the controlled page. This give me control of the file
  operations and arbitrary read/write.
  From here, I remove the chroot and edit my creds to make that thread root.
  */
