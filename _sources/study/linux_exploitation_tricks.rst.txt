.. include:: /pentest_links.txt


*************************
Linux Exploitation Tricks
*************************

Privilege Escalation
====================

Here are 2 links to investiage privilege escalation:

* `Basic Linux Privilege Escalation <http://blog.g0tmi1k.com/2011/08/basic-linux-privilege-escalation/>`_

* `Understanding Privilege Escalation <http://www.admin-magazine.com/Articles/Understanding-Privilege-Escalation>`_
       


Miscelaneous Exploits
=====================

`Hacking Linux Part I: Privilege Escalation By gimboyd <http://www.dankalia.com/tutor/01005/0100501004.htm>`_ is a short read of these exploits:

* Abusing users with '.' in their PATH:

* Shell Escape Sequences: (applications that allow you to run a shell)

* IFS Exploit:

* LD_PRELOAD Exploit: (covered in more detail in :ref:`overriding_libraries`)

* symlinks


Of the above the IFS (internal field separator) is perhaps the most confusing for beginners so we provide an IFS example below. From ``man bash``:

  IFS The Internal Field Separator that is used for word splitting after expansion and to  split  lines  into words with the read builtin command.  The default value is "<space><tab><newline>".

Here is an example in C and bash illustrating some differences how IFS works:


.. code-block:: console


  $ export IFS=/
  $ # test.sh runs "/bin/date" and "eval /bin/date"
  $ cat test.sh
  #!/usr/bin/env bash

  echo -n "$IFS" | od -bc
  echo try 1
  /bin/date
  echo try 2
  cmd="/bin/date"; eval $cmd
  $ # test.sh ignores inherited IFS
  $ ./test.sh
  0000000 040 011 012
               \t  \n
  0000003
  try 1
  Fri Sep  5 15:21:13 PDT 2014
  try 2
  Fri Sep  5 15:21:13 PDT 2014
  $ # ". ./test.sh" uses IFS and sees "eval /bin/date" as "bin date"
  $ . ./test.sh
  0000000 057
            /
  0000001
  try 1
  Fri Sep  5 15:21:25 PDT 2014
  try 2
  -bash: bin: command not found
  $ # . test.c duplicates test.sh and acts like ". ./test.sh"
  $ cat test.c
  #include <stdlib.h>
  main()
  {
    system("echo -n \"$IFS\" | od -bc");
    system("echo try 1");
    system("/bin/date");
    system("echo try 2");
    system("cmd=\"/bin/date\"; eval $cmd");
  }
  $ gcc -o test test.c
  $ chmod +x test
  $ ./test
  0000000 057
            /
  0000001
  try 1
  Fri Sep  5 15:22:10 PDT 2014
  try 2
  sh: 1: eval: bin: not found
  $ 



Initializing Uninitialized Memory
=================================

`Controlling uninitialized memory with LD_PRELOAD <http://vulnfactory.org/blog/2010/04/08/controlling-uninitialized-memory-with-ld_preload/>`_ mentions that 

  The source of this technique is in the way the Linux linker/loader, ld.so, handles the LD_PRELOAD environment variable. This variable allows users to specify libraries to be preloaded, effectively allowing users to override functions used in a particular binary. Of course, the LD_PRELOAD variable is ignored with setuid binaries, since otherwise an attacker could trivially override arbitrary functions in setuid binaries and easily take control of a system.

  However, regardless of whether or not libraries specified via LD_PRELOAD are actually loaded at runtime, ld.so copies the name of each library onto the stack prior to executing the program, and doesnâ€™t clean up after itself. By specifying a very long LD_PRELOAD variable and executing a binary, a portion of the stack will be overwritten with part of the LD_PRELOAD variable during linking, and it will stay that way once execution of the program begins, even on setuid binaries, where the library itself is not loaded.


So here goes an example of loading some of memory with the letter "A":

.. code-block:: console

  hacker@kali64:~$ LD_PRELOAD=$(python -c 'print("A"*1000)') date
  ERROR: ld.so: object 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA' from LD_PRELOAD cannot be preloaded (cannot open shared object file): ignored.
  Thu Sep  4 21:55:18 PDT 2014
  hacker@kali64:~$ 

.. _overriding_libraries:

Overriding Libraries
====================

A nifty trick is to override libraries. Consult `Static, Shared Dynamic and Loadable Linux Libraries <http://www.yolinux.com/TUTORIALS/LibraryArchives-StaticAndDynamic.html>`_ for an overview of libraries and `ld-linux(8) - Linux man page <http://linux.die.net/man/8/ld-linux>`_ for the LD_* environment variables.

Of course these tricks won't work for a setuid/setgid program (unless ruid = euid, that is real uid = effective uid).

LD_PRELOAD Hack
---------------

Suppose a non-setuid program calls a libc routine, say ``puts()`` and you'd like to either override that call or inject code before/after that call. One method is to build a shared library redefining ``puts()`` and use LD_PRELOAD to force it to be preloaded & override libc's ``puts()``. The example below is a conglomeration of ideas found in these articles: 
`LD PRELOAD notes <http://www.noah.org/wiki/LD_PRELOAD_notes>`_, `The linux-- function hijacking -- Based on LD_PRELOAD <http://www.programering.com/a/MzN3YzMwATY.html>`_, `The magic of LD_PRELOAD for Userland Rootkits <http://fluxius.handgrep.se/2011/10/31/the-magic-of-ld_preload-for-userland-rootkits/>`_ (the last 2 links show handling a variable number of arguments).

Below, *main.c* just prints a simple message. *puts-replace.c* replaces it with an ``exit(153)``, while *puts-inject.c* injects a write to file *evil.txt* prior to passing the call on to the real, original ``puts()``.


.. code-block:: console

  hacker@kali64:~/local/LD_PRELOAD$ # the unmodified program
  hacker@kali64:~/local/LD_PRELOAD$ cat main.c
  #include <stdio.h>
  main()
  {
    puts("Hello");
    puts("Goodbye");
  } 
  hacker@kali64:~/local/LD_PRELOAD$ gcc -o main main.c
  hacker@kali64:~/local/LD_PRELOAD$ ./main
  Hello
  Goodbye
  hacker@kali64:~/local/LD_PRELOAD$ # replace puts with exit(153)
  hacker@kali64:~/local/LD_PRELOAD$ cat puts-replace.c
  #include <stdio.h>
  #include <stdlib.h>
  int puts(const char *s)
  {
    // this puts just silently exits the whole program
    exit(153);
  }
  hacker@kali64:~/local/LD_PRELOAD$ gcc -shared -fPIC -D_GNU_SOURCE \
      -o puts-replace.so puts-replace.c
  hacker@kali64:~/local/LD_PRELOAD$ LD_PRELOAD=$PWD/puts-replace.so ./main
  hacker@kali64:~/local/LD_PRELOAD$ echo $?
  153
  hacker@kali64:~/local/LD_PRELOAD$ # inject code in puts - write to evil.txt
  hacker@kali64:~/local/LD_PRELOAD$ cat puts-inject.c
  #include <dlfcn.h>
  #include <stdio.h>
  int puts(const char *s)
  {
    static int (*orig_puts) (const char *s) = NULL;

    // inject evil code here
    FILE *fp = fopen("evil.txt", "a");
    fprintf(fp, "%s\n", "some secret");
    fclose(fp);

    // dynamically load original puts if needed, then call it
    if (orig_puts == NULL)
      orig_puts = (int (*)()) dlsym(RTLD_NEXT, "puts");
    return (*orig_puts)(s);
  }
  hacker@kali64:~/local/LD_PRELOAD$ gcc -shared -ldl -fPIC -D_GNU_SOURCE \
      -o puts-inject.so puts-inject.c
  hacker@kali64:~/local/LD_PRELOAD$ LD_PRELOAD=$PWD/puts-inject.so ./main
  Hello
  Goodbye
  hacker@kali64:~/local/LD_PRELOAD$ cat evil.txt
  some secret
  some secret
  hacker@kali64:~/local/LD_PRELOAD$ 

Using ``nm -D`` we can view the "U" undefined and "T" defined symbols in our *main* and two shared objects *puts-replace.so* and *puts-inject.so*.

.. code-block:: console

  hacker@kali64:~/local/LD_PRELOAD$ 
  hacker@kali64:~/local/LD_PRELOAD$ # main requires puts (and __libc_start_main)
  hacker@kali64:~/local/LD_PRELOAD$ nm -D main
  ###################### SNIP ######################
                   U __libc_start_main
                   U puts
  hacker@kali64:~/local/LD_PRELOAD$ 
  hacker@kali64:~/local/LD_PRELOAD$ # puts-replace.so provides puts and requires exit
  hacker@kali64:~/local/LD_PRELOAD$ nm -D puts-replace.so
  ###################### SNIP ######################
                   U exit
  00000000000006c0 T puts
  hacker@kali64:~/local/LD_PRELOAD$ 
  hacker@kali64:~/local/LD_PRELOAD$ # puts-inject.so provides puts and requires 
  hacker@kali64:~/local/LD_PRELOAD$ #   support for the injected code 
  hacker@kali64:~/local/LD_PRELOAD$ nm -D puts-inject.so
  ###################### SNIP ######################
                   U dlsym
                   U fclose
                   U fopen
                   U fprintf
  00000000000007c0 T puts
  hacker@kali64:~/local/LD_PRELOAD$ 




RPATH and Environment Variables
-------------------------------

ELF file RPATH specification and environment variables affect the load order for an executable. When looking for an exploit you can check the ELF file to see if there is an RPATH specification that might allow overriding a shared library:


.. code-block:: console

  hacker@kali64:~$ readelf --dynamic /usr/bin/some_exe | grep PATH
   0x000000000000000f (RPATH)    Library rpath: [/usr/lib/binutils/avr/git]
   0x000000000000001d (RUNPATH)  Library runpath: [/usr/lib/binutils/avr/git]



`ld.so(8) man page <http://man7.org/linux/man-pages/man8/ld.so.8.html>`_ description section mentions the library search order:


  When resolving library dependencies, the dynamic linker first inspects each dependency string to see if it contains a slash (this can occur if a library pathname containing slashes was specified at link time). If a slash is found, then the dependency string is interpreted as a (relative or absolute) pathname, and the library is loaded using that pathname.

  If a library dependency does not contain a slash, then it is searched for in the following order:

  * (ELF only) Using the directories specified in the DT_RPATH dynamic section attribute of the binary if present and DT_RUNPATH attribute does not exist. Use of DT_RPATH is deprecated.

  * Using the environment variable LD_LIBRARY_PATH. Except if the executable is a set-user-ID/set-group-ID binary, in which case it is ignored.

  * (ELF only) Using the directories specified in the DT_RUNPATH dynamic section attribute of the binary if present.

  * From the cache file /etc/ld.so.cache, which contains a compiled list of candidate libraries previously found in the augmented library path. If, however, the binary was linked with the -z nodeflib linker option, libraries in the default library paths are skipped. Libraries installed in hardware capability directories (see below) are preferred to other libraries.

  * In the default path /lib, and then /usr/lib. If the binary was linked with the -z nodeflib linker option, this step is skipped.

So where does this leave us? Check the ELF for additional RPATH specification that contains a writable directory.



setuid executables
==================

A setuid executable is created via ``chmod u+s``. This affects several aspects of running the program: the started process runs as the owning user of the program file, and the invoking user is prohibited from altering the new process in any way. So running ``gdb`` on a setuid program actually runs it as a normal non-setuid program. Altering LD_LIBRARY_PATH, ``ptrace``, or other attempts to alter the program are also not permitted. To find setuid/setgid programs:


.. code-block:: bash

  # find setuid or getuid programs
  find / -type f -perm /6000 -exec stat -c "%A %a %n" {} \;
  # find only setuid programs
  find / -type f -perm /4000



real/effective/saved uid's
--------------------------

Sometimes setuid programs drop permissions in a way that allows the program to revert back to root. To understand this you should be aware that the process has 3 important uids: real (ruid), effective (euid), and saved (suid). The ruid starts out as the uid of the executing user, euid as the owner of the setuid program, and suid the same as euid. From there the program can use different methods to drop permissions, some of which can be reversed.

  Side Note: Linux has a fourth uid, the fsuid `filesystem user ID <https://en.wikipedia.org/wiki/User_identifier#File_system_user_ID>`_ "which is used explicitly for access control to the file system. It matches the euid unless explicitly set otherwise. It may be root's user ID only if ruid, suid, or euid is root. Whenever the euid is changed, the change is propagated to the fsuid." There are equivalent group real, effective and saved gids.

You can see your uid & gid via the ``id`` command and view all four of your real/effective/saved/fs uid's & gid's as the first three after *Uid* in ``cat /proc/$$/task/$$/status | grep -A2 TracerPid``:

.. code-block:: console

  hacker@kali64:~$ cat /proc/$$/task/$$/status | grep -A2 TracerPid
  TracerPid:	0
  Uid:	1000	1000	1000	1000
  Gid:	1001	1001	1001	1001


Changing uid's
--------------

When dropping permissions from root it may be possible to revert to root depending on how permissions were dropped. Here are the restrictions on changing these id's from `setresuid() <http://linux.die.net/man/2/setresuid>`_:

  Unprivileged user processes may change the real UID, effective UID, and saved set-user-ID, each to one of: the current real UID, the current effective UID or the current saved set-user-ID.

  Privileged processes (on Linux, those having the CAP_SETUID capability) may set the real UID, effective UID, and saved set-user-ID to arbitrary values.

The following setuid C program starts off by showing all 4 uids set to root then back to to their original values. It then illustrates the difference between ``seteuid()`` and ``setuid()``: ``setuid()`` also sets the suid and so cannot revert to root. Additionally, starting a subprocess via ``system()`` sets suid to the euid preventing the subprocess reverting to root.

.. code-block:: c

  #include <stdio.h>
  #include <stdlib.h>
  #include <sys/types.h>
  #include <unistd.h>

  void printit(void)
  {
      uid_t ruid, euid, suid;
      getresuid(&ruid, &euid, &suid);
      printf("UID:    %-4d    %-4d    %-4d \n", ruid, euid, suid);
      system("cat /proc/$$/task/$$/status | grep -i uid");
      return;
  }

  int main()
  {
     // Starting with
     printf("******* Starting out\n");
     printit();
     printf("******* setresuid(0,0,0) illustrate setting all uids to root\n");
     setresuid(0,0,0);
     printit();
     printf("******* setresuid(1000,0,0) get uids back to starting values\n");
     setresuid(1000,0,0);
     printit();
     printf("******* seteuid(1000) lowers to 1000 and process can raise to root\n");
     seteuid( 1000 );
     printit();
     printf("******* seteuid(0) back at root\n");
     seteuid( 0 );
     printit();
     printf("******* setuid(1000) also sets suid\n");
     setuid( 1000 );
     printit();
     printf("******* setuid(0) suid 1000 stops raise to root\n");
     setuid( 0 );
     printit();

     return 0;
  }



.. code-block:: console

  hacker@kali64:~$ cat > test.sh <<EOF
  #!/usr/bin/env bash

  gcc test.c -o test
  sudo chown root.root test
  sudo chmod u+s test
  EOF
  hacker@kali64:~$ ./test.sh
  hacker@kali64:~$ ./test
  ******* Starting out
  UID:    1000    0       0    
  Uid:	1000	0	0	0
  ******* setresuid(0,0,0) illustrate setting all to root
  UID:    0       0       0    
  Uid:	0	0	0	0
  ******* setresuid(1000,0,0) get back to start
  UID:    1000    0       0    
  Uid:	1000	0	0	0
  ******* seteuid(1000) lowers to 1000 and process can raise to root
  UID:    1000    1000    0    
  Uid:	1000	1000	1000	1000
  ******* seteuid(0) back at root
  UID:    1000    0       0    
  Uid:	1000	0	0	0
  ******* setuid(1000) also sets suid
  UID:    1000    1000    1000 
  Uid:	1000	1000	1000	1000
  ******* setuid(0) suid 1000 stops raise to root
  UID:    1000    1000    1000 
  Uid:	1000	1000	1000	1000
  hacker@kali64:~$ 
